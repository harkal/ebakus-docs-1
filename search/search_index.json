{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction to ebakus \u00b6 The ebakus development stack allows developers to create highly responsive and frictionless decentralized applications that are a delight for users to use. The backbone of the ebakus development stack is the ebakus blockchain. It is fast, it has free transactions while remaining sybil resistant and is 100% backwards compatible with ethereum\u2019s go-ethereum node. This means that everything you have built for ethereum can be easily ported to work with ebakus. Besides the performance and accessibility improvements, ebakus also extends Solidity with ebakusDB. A decentralized transactional database that makes handling of large datasets a breeze. It supports tables with multiple indexes and allows to sort large datasets fast and easy. DPOS consensus \u00b6 Ebakus owes its low latency and high throuput to the Delegated Proof of Stake (DPOS) consensus algorithm that was originally introduced by Dan Larimer and first brought into production in bitshares. In DPOS the blocks are produced by the block producers , which are elected through a continuous approval voting system. Block producers are selected among a number of nodes willing to produce blocks called witnesses . Anyone can choose to become a witness, but only those that accumulate the most votes acquire the right to produce blocks. The voting power of each stake holder in the network is proportional to their stake -the number of tokens they hold- in the network. This creates a significantly more agile and attack resilient system than PoW. A DPOS system can quickly heal in the events of byzantine actors trying to manipulate the network. Ebakus has 21 block producers, the 20 top voted witnesses become block producers the 21st is randomly selected by the top voted 21-100 witnesses to incentivise them to run their infrastructure and make sure that backup block producers are available. The ebakus blockchain by default produces one block every second and at each second only one producer has the authority to produce a block. Free transactions \u00b6 One of the main reasons we decided to built ebakus was to improve usability of decentralized applications. When we started looking into viable business models and ideas for dApps, we quickly found out that fees and complex resource management systems really hindered usability. The requirement for users to own an initial token balance in order to interact with decentralized applications was really hurting onboarding of new users that had no previous experience with blockchain applications and it was one of the first problems we built ebakus to solve. Blockchains today use fees in order to achieve two main goals. First, to mitigate malicious unsolicited flooding of the network with a huge number of transactions in order to affect the quality of service for normal operations, and use up storage and processing capacity. Second, to incentivise the miners or block producers as they collect those fees. Adding fees to every transaction greatly hinders the usability of a blockchain. One of our main design goal with ebakus software is to provide free transactions. We do this by solving the two aforementioned problems. We solve the incentive problem by using inflation. The block producers don\u2019t depend on the fees of transactions as the software constantly creates new ebakus coins as a reward for them. So now, we have to address the spamming of the network in order to make the inflation truly compensate for the lack of fees additionally to maintaining the quality of service. We achieve this by utilising an algorithm that uses proof of work in combination with proof of stake. The initial invention of PoW was actually for use in mitigating network denial of service. Most blockchains ended up using fees in order to make it expensive to attack the network, while killing usability and eventually failing to maintain quality of service. In ebakus the network maintains a PoW quantum value. This is the minimum work required by a non stake holder -we will come back to that- for the unit operation on the network. Each operation on the network requires to consume a number PoW quanta in order to be accepted depending on the complexity of computation, the storage requirements, etc. The block providers adjust this PoW quantum to the level that allows normal operation of the network. For example if the network is idle with very little transactions being processed, transactions will require very low PoW to be accepted. In the event someone starts spamming the network with transactions the PoW quantum will be increased so it becomes computationally expensive for him to continue doing so. However, in order to achieve quality of service for the legitimate users of the network ebakus does not operate entirely on the global PoW quantum. The global PoW quantum essentially the work quantum required by accounts holding zero amount of ebakus coins. The actual work quantum accepted is adjusted for each account as a function of its stake. Accounts that hold more ebakus coins -and hence have more stake- have a lesser PoW quantum. The PoW quantum is adjusted in a way that, at anytime, the network resources are allocated proportionally to all the stake holders sending transactions. Ebakus wallets will be able to recalculate the PoW required to send a transaction, so even in cases that the account has zero stake and the network is congested, the user experience will be smooth. The EBK token \u00b6 The ebk token is the native token of the ebakus network, its main uses are: to vote for block producers and secure the infrastructure of the network to be staked and allow clients to do less proof of work in order to send transactions to the network ebakusDB \u00b6 Each smart contract in ebakus has its own schema defined database (ESDD). This database can support any number of tables with typed fields and indexes. A smart contract is able to perform the following operations on the data: Create/Drop tables Create/Drop indexes on specific fields Retrieve/Update/Delete single or multiple rows of data do ordered range queries on these data The ebakus software makes sure that the data are stored in such a way in order to support the above operations in the most efficient way. The smart contract should not need to implement most common query types by itself. The EbakusDB layer is providing to the ebakus blockchain a very fast database layer that supports O(1) time and space complexity snapshots. This is essential to the operation of a blockchain system that has requirements for querying old block states. The database achieves high performance by being aware of the transactional log functionality that the layer above it is using and not reimplementing it itself. Therefore achieving ACID compliance without sacrificing performance. Smart contracts deployed in Ethereum compatibility mode will not be able to make use of the ESDD, hence will not be able to benefit from the extra functionality and performance. Bellow you can see how ebakusDB performs compared with Google\u2019s LevelDB. The ebakus development stack \u00b6 The ebakus development stack consists of: the ebakus node: DPOS, 1 second blocks, ebakusDB web3-ebakus: is an extentention of ethereum\u2019s popular web3 library to enable calculation of PoW and access ebakusDB the wallet-loader library: can be included on any static site and provide an interface to the ebakus blockchain through the web wallet. the ebakus web wallet: is the interface to the ebakus network. The ebakus development stack allows for applications that are easy to use as any other application built on centralized infrastructure while remaining completely decentralized (without the need to rely on hybrid models). Besides the speed, the key to achieving great UX is avoiding transaction costs either in the form of fees or complicated resource systems, while also remaining sybil resistant. Building on ebakus \u00b6 ebakus is quite easy to pick up especially for ethereum and tron developers try our getting started with ebakus development article to familiarize yourself with the ebakus development stack and start building apps in no time.","title":"General Information"},{"location":"#introduction-to-ebakus","text":"The ebakus development stack allows developers to create highly responsive and frictionless decentralized applications that are a delight for users to use. The backbone of the ebakus development stack is the ebakus blockchain. It is fast, it has free transactions while remaining sybil resistant and is 100% backwards compatible with ethereum\u2019s go-ethereum node. This means that everything you have built for ethereum can be easily ported to work with ebakus. Besides the performance and accessibility improvements, ebakus also extends Solidity with ebakusDB. A decentralized transactional database that makes handling of large datasets a breeze. It supports tables with multiple indexes and allows to sort large datasets fast and easy.","title":"Introduction to ebakus"},{"location":"#dpos-consensus","text":"Ebakus owes its low latency and high throuput to the Delegated Proof of Stake (DPOS) consensus algorithm that was originally introduced by Dan Larimer and first brought into production in bitshares. In DPOS the blocks are produced by the block producers , which are elected through a continuous approval voting system. Block producers are selected among a number of nodes willing to produce blocks called witnesses . Anyone can choose to become a witness, but only those that accumulate the most votes acquire the right to produce blocks. The voting power of each stake holder in the network is proportional to their stake -the number of tokens they hold- in the network. This creates a significantly more agile and attack resilient system than PoW. A DPOS system can quickly heal in the events of byzantine actors trying to manipulate the network. Ebakus has 21 block producers, the 20 top voted witnesses become block producers the 21st is randomly selected by the top voted 21-100 witnesses to incentivise them to run their infrastructure and make sure that backup block producers are available. The ebakus blockchain by default produces one block every second and at each second only one producer has the authority to produce a block.","title":"DPOS consensus"},{"location":"#free-transactions","text":"One of the main reasons we decided to built ebakus was to improve usability of decentralized applications. When we started looking into viable business models and ideas for dApps, we quickly found out that fees and complex resource management systems really hindered usability. The requirement for users to own an initial token balance in order to interact with decentralized applications was really hurting onboarding of new users that had no previous experience with blockchain applications and it was one of the first problems we built ebakus to solve. Blockchains today use fees in order to achieve two main goals. First, to mitigate malicious unsolicited flooding of the network with a huge number of transactions in order to affect the quality of service for normal operations, and use up storage and processing capacity. Second, to incentivise the miners or block producers as they collect those fees. Adding fees to every transaction greatly hinders the usability of a blockchain. One of our main design goal with ebakus software is to provide free transactions. We do this by solving the two aforementioned problems. We solve the incentive problem by using inflation. The block producers don\u2019t depend on the fees of transactions as the software constantly creates new ebakus coins as a reward for them. So now, we have to address the spamming of the network in order to make the inflation truly compensate for the lack of fees additionally to maintaining the quality of service. We achieve this by utilising an algorithm that uses proof of work in combination with proof of stake. The initial invention of PoW was actually for use in mitigating network denial of service. Most blockchains ended up using fees in order to make it expensive to attack the network, while killing usability and eventually failing to maintain quality of service. In ebakus the network maintains a PoW quantum value. This is the minimum work required by a non stake holder -we will come back to that- for the unit operation on the network. Each operation on the network requires to consume a number PoW quanta in order to be accepted depending on the complexity of computation, the storage requirements, etc. The block providers adjust this PoW quantum to the level that allows normal operation of the network. For example if the network is idle with very little transactions being processed, transactions will require very low PoW to be accepted. In the event someone starts spamming the network with transactions the PoW quantum will be increased so it becomes computationally expensive for him to continue doing so. However, in order to achieve quality of service for the legitimate users of the network ebakus does not operate entirely on the global PoW quantum. The global PoW quantum essentially the work quantum required by accounts holding zero amount of ebakus coins. The actual work quantum accepted is adjusted for each account as a function of its stake. Accounts that hold more ebakus coins -and hence have more stake- have a lesser PoW quantum. The PoW quantum is adjusted in a way that, at anytime, the network resources are allocated proportionally to all the stake holders sending transactions. Ebakus wallets will be able to recalculate the PoW required to send a transaction, so even in cases that the account has zero stake and the network is congested, the user experience will be smooth.","title":"Free transactions"},{"location":"#the-ebk-token","text":"The ebk token is the native token of the ebakus network, its main uses are: to vote for block producers and secure the infrastructure of the network to be staked and allow clients to do less proof of work in order to send transactions to the network","title":"The EBK token"},{"location":"#ebakusdb","text":"Each smart contract in ebakus has its own schema defined database (ESDD). This database can support any number of tables with typed fields and indexes. A smart contract is able to perform the following operations on the data: Create/Drop tables Create/Drop indexes on specific fields Retrieve/Update/Delete single or multiple rows of data do ordered range queries on these data The ebakus software makes sure that the data are stored in such a way in order to support the above operations in the most efficient way. The smart contract should not need to implement most common query types by itself. The EbakusDB layer is providing to the ebakus blockchain a very fast database layer that supports O(1) time and space complexity snapshots. This is essential to the operation of a blockchain system that has requirements for querying old block states. The database achieves high performance by being aware of the transactional log functionality that the layer above it is using and not reimplementing it itself. Therefore achieving ACID compliance without sacrificing performance. Smart contracts deployed in Ethereum compatibility mode will not be able to make use of the ESDD, hence will not be able to benefit from the extra functionality and performance. Bellow you can see how ebakusDB performs compared with Google\u2019s LevelDB.","title":"ebakusDB"},{"location":"#the-ebakus-development-stack","text":"The ebakus development stack consists of: the ebakus node: DPOS, 1 second blocks, ebakusDB web3-ebakus: is an extentention of ethereum\u2019s popular web3 library to enable calculation of PoW and access ebakusDB the wallet-loader library: can be included on any static site and provide an interface to the ebakus blockchain through the web wallet. the ebakus web wallet: is the interface to the ebakus network. The ebakus development stack allows for applications that are easy to use as any other application built on centralized infrastructure while remaining completely decentralized (without the need to rely on hybrid models). Besides the speed, the key to achieving great UX is avoiding transaction costs either in the form of fees or complicated resource systems, while also remaining sybil resistant.","title":"The ebakus development stack"},{"location":"#building-on-ebakus","text":"ebakus is quite easy to pick up especially for ethereum and tron developers try our getting started with ebakus development article to familiarize yourself with the ebakus development stack and start building apps in no time.","title":"Building on ebakus"},{"location":"migrating-your-erc-20-ebk-to-native-ebk-for-the-mainnet/","text":"Migrating your ERC-20 EBK tokens to native EBK for the mainnet \u00b6 After January 1 2020, the erc-20 EBK token will freeze and the transition to mainnet will begin. The ebakus mainnet is designed to be backwards compatible with ethereum and thus maintains the address format of ethereum. When we launch the mainnet we will make sure that every address that holds frozen ERC-20 EBK tokens will get an equal balance of native EBK token. This means that the transition from the ERC-20 EBK to the native EBK to be a passive event without any further action required by the ERC-20 EBK token owners. All ERC-20 EBK token owners will have to do, in order to access their Native EBK tokens will be to import the private key that is being used in the ERC-20 wallet that stores the frozen ERC-20 EBK tokens into an ebakus wallet connected to the ebakus mainnet. More information about the mainnet ebakus wallet and status updates about the transition to mainnet will be released through our channels as we proceed. Tip Ideally create a new ERC-20 wallet just for your ERC-20 EBK tokens and use that Public/Private key pair to transition to the ebakus mainnet. Danger Beware of scams, make sure you use an ebakus mainnet wallet that is opensource and vetted by the community.","title":"Migrating your ERC-20 EBK to Native EBK for the mainnet"},{"location":"migrating-your-erc-20-ebk-to-native-ebk-for-the-mainnet/#migrating-your-erc-20-ebk-tokens-to-native-ebk-for-the-mainnet","text":"After January 1 2020, the erc-20 EBK token will freeze and the transition to mainnet will begin. The ebakus mainnet is designed to be backwards compatible with ethereum and thus maintains the address format of ethereum. When we launch the mainnet we will make sure that every address that holds frozen ERC-20 EBK tokens will get an equal balance of native EBK token. This means that the transition from the ERC-20 EBK to the native EBK to be a passive event without any further action required by the ERC-20 EBK token owners. All ERC-20 EBK token owners will have to do, in order to access their Native EBK tokens will be to import the private key that is being used in the ERC-20 wallet that stores the frozen ERC-20 EBK tokens into an ebakus wallet connected to the ebakus mainnet. More information about the mainnet ebakus wallet and status updates about the transition to mainnet will be released through our channels as we proceed. Tip Ideally create a new ERC-20 wallet just for your ERC-20 EBK tokens and use that Public/Private key pair to transition to the ebakus mainnet. Danger Beware of scams, make sure you use an ebakus mainnet wallet that is opensource and vetted by the community.","title":"Migrating your ERC-20 EBK tokens to native EBK for the mainnet"},{"location":"becoming-a-block-producer/becoming-a-block-producer/","text":"Introduction \u00b6 The ebakus blockchain uses Delegated Proof of Stake as its consensus algorithm (DPOS). In DPOS anyone can propose to become part of the infrastructure and produce blocks to receive mining rewards, by running a full node and becoming a witness. Being a witness makes you an embassador of the ebakus ecosystem, besides being a pillar of the network by providing infrastructure you take on the responsibilitty to help it grow. In ebakus, EBK token holders can cast 1 vote for every EBK they hold, to up to 20 witnesses at a time. Witnesses campaign for votes from the EBK token holders and when they manage to gather enough votes to enter the top 20 most voted, they elevate to block producer status. As block producers they are actively part of the consensus by producing blocks and earning mining rewards for every block they produce. The 21st block producer \u00b6 Until witnesses gather enough votes to become block producers they can still earn rewards if they maintain a position within the top 100 witnesses through the 21st block producer. The 21st block producer is selected randomly with every cycle from the top 21st-100th witnesses. This design motivates witnesses up to top 100th to keep their infrastructure running and be available to take over as back up BPs. Where to start \u00b6 Become an ebakus evangelist \u00b6 As we mentinoned above being a block producer also means that you are a pillar of the ebakus community, as it helps you get voted higher. You can start your journey to becoming a block producer today by becoming an active member of the ebakus community. Participate in the ebakus social channels, create dApps or organize ebakus meet ups localy and when you are ready start running a full node and become a witness. The technical part \u00b6 For the technical side of things, you can follow our guides of running a witness and hardening the security of your server. Ideally block producers should at least follow our proposed specification as you can find it here.","title":"Introduction"},{"location":"becoming-a-block-producer/becoming-a-block-producer/#introduction","text":"The ebakus blockchain uses Delegated Proof of Stake as its consensus algorithm (DPOS). In DPOS anyone can propose to become part of the infrastructure and produce blocks to receive mining rewards, by running a full node and becoming a witness. Being a witness makes you an embassador of the ebakus ecosystem, besides being a pillar of the network by providing infrastructure you take on the responsibilitty to help it grow. In ebakus, EBK token holders can cast 1 vote for every EBK they hold, to up to 20 witnesses at a time. Witnesses campaign for votes from the EBK token holders and when they manage to gather enough votes to enter the top 20 most voted, they elevate to block producer status. As block producers they are actively part of the consensus by producing blocks and earning mining rewards for every block they produce.","title":"Introduction"},{"location":"becoming-a-block-producer/becoming-a-block-producer/#the-21st-block-producer","text":"Until witnesses gather enough votes to become block producers they can still earn rewards if they maintain a position within the top 100 witnesses through the 21st block producer. The 21st block producer is selected randomly with every cycle from the top 21st-100th witnesses. This design motivates witnesses up to top 100th to keep their infrastructure running and be available to take over as back up BPs.","title":"The 21st block producer"},{"location":"becoming-a-block-producer/becoming-a-block-producer/#where-to-start","text":"","title":"Where to start"},{"location":"becoming-a-block-producer/becoming-a-block-producer/#become-an-ebakus-evangelist","text":"As we mentinoned above being a block producer also means that you are a pillar of the ebakus community, as it helps you get voted higher. You can start your journey to becoming a block producer today by becoming an active member of the ebakus community. Participate in the ebakus social channels, create dApps or organize ebakus meet ups localy and when you are ready start running a full node and become a witness.","title":"Become an ebakus evangelist"},{"location":"becoming-a-block-producer/becoming-a-block-producer/#the-technical-part","text":"For the technical side of things, you can follow our guides of running a witness and hardening the security of your server. Ideally block producers should at least follow our proposed specification as you can find it here.","title":"The technical part"},{"location":"becoming-a-block-producer/hardening-security/","text":"","title":"Hardening security"},{"location":"becoming-a-block-producer/proposed-specification/","text":"","title":"Proposed specification"},{"location":"becoming-a-block-producer/running-a-witness/","text":"Becoming a block producer \u00b6 For becoming a block producer you have to get a synced node with the network. To reach to that state, let\u2019s get the needed ingredients to start our node. Let\u2019s set a folder in our system where we will store both our secrets and the data of our node. export BASE_PATH = ~/ebakus-producer mkdir -p ${ BASE_PATH } Important This doc refers on how to become a block producer on the mainnet . If you would like to experiment on testnet add the --testnet flag. Create an account for the block producer \u00b6 Create a password file for your account \u00b6 It\u2019s up to you to decide how to generate the password for your account. Here you can find an example command: openssl rand -base64 32 > ${ BASE_PATH } /passwd Create the account \u00b6 docker run --rm --name ebakus-producer \\ -v ${ BASE_PATH } :/root \\ -p 30403 :30403 \\ -p 30403 :30403/udp \\ ebakus/go-ebakus \\ account new \\ --password /root/passwd Example output Your new key was generated Public address of the key : 0 xA356eF85BB1740eC494B3c4eDA230aBd64D571F8 Path of the secret key file : / root / . ebakus / keystore / UTC --2019-12-17T13-44-28.902899300Z--a356ef85bb1740ec494b3c4eda230abd64d571f8 From the above we need to note our public address. That is 0xA356eF85BB1740eC494B3c4eDA230aBd64D571F8 in this example. Starting the producer \u00b6 We start our producer, having opened the 30403 port in the docker for connecting to the P2P network. We then set our etherbase and password as well unlocking the account. docker run -d --name ebakus-producer \\ -v ${ BASE_PATH } :/root \\ -p 30403 :30403 \\ -p 30403 :30403/udp \\ ebakus/go-ebakus \\ --etherbase 0xA356eF85BB1740eC494B3c4eDA230aBd64D571F8 \\ --unlock 0xA356eF85BB1740eC494B3c4eDA230aBd64D571F8 \\ --password /root/passwd Stopping the producer \u00b6 It is important that you properly stop a running produser. Simply killing the ebakus process, or the docker container, will probably result in a corrupted state database that will require a complete resync of the node. To avoid the constly resync, it is important to allow the producer to gracefully shutdown. We do this by sending it the SIGTERM signal. This is accomplished by the command below: docker kill --signal = SIGTERM ebakus-producer Info Stopping a producer will result in missed blocks. Read the Step down as a witness section in this guide on how to avoid this. Monitor syncing \u00b6 Now we have to wait for the node to be synced. We can check the progress by attaching to the docker container like: docker exec -it ebakus-producer ebakus attach Inside the attached console we can check if we are currently syncing which has to return false . eth . syncing // -- Output -- // false And also to check if the blockNumber is the latest one in our explorer as well. eth . blockNumber Control the producer \u00b6 Once you are ready, set node active for producing. docker exec -it ebakus-producer ebakus attach miner . start () // -- Output -- // true Tip After the initial sync and being added as a witness you can add --mine flag in the docker startup script for auto mining. Also you ask docker to automatically restart when something happens --restart unless-stopped in the docker params. Allow to be voted as a witness \u00b6 For electing ourselves as a witness we have to send a transaction on the system contract 0x0000000000000000000000000000000000000101 . For doing so we need to attach to the docker container: docker exec -it ebakus-producer ebakus attach To set \u201c electEnable \u201d to true you must again send a transaction to the system like this: var systemContractAddress = '0x0000000000000000000000000000000000000101' ; var systemContractABI = eth . getAbiForAddress ( systemContractAddress ); systemContractABI = JSON . parse ( systemContractABI ); var systemContract = eth . contract ( systemContractABI ). at ( systemContractAddress ); systemContract . electEnable ( true ); Information on Proof of Work (PoW) For more information on PoW check here . Step down as a witness \u00b6 There are cases when you will need to step down from producing blocks. These include: Experiencing technical difficulties During software updates No longer wanting to participate in the Ebakus network In these cases or any other when you will not be able/willing to produce blocks, it is important that you inform the network of your intention by setting \u201c electEnable \u201d to false . Users are monitoring the network for producers that miss blocks, and you don\u2019t want to be seen as a bad performing producer possibly resulting in lost votes. Setting \u201c electEnable \u201d to false will prevent you from losing blocks while you are experiencing any difficulty. To set \u201c electEnable \u201d to false you must again send a transaction to the system like this: var systemContractAddress = '0x0000000000000000000000000000000000000101' ; var systemContractABI = eth . getAbiForAddress ( systemContractAddress ); systemContractABI = JSON . parse ( systemContractABI ); var systemContract = eth . contract ( systemContractAddress ). at ( systemContractAddress ); systemContract . electEnable ( false ); Be voted \u00b6 In order to produce a block you need to be in the top 100 witnesses. For attracting others to vote you, you can help the community and ask others to vote you. Tip Don\u2019t forget to vote for yourself!!! \ud83d\ude00 The easier way to vote is by visiting the Ebakus explorer statistics and use the Ebakus wallet. Although, in case you want to vote yourself from within the go-ebakus node, here is some example code. This example will stake your whole balance at the moment running the command. Stake whole balance var systemContractAddress = '0x0000000000000000000000000000000000000101' ; var systemContractABI = eth . getAbiForAddress ( systemContractAddress ); systemContractABI = JSON . parse ( systemContractABI ); var systemContract = eth . contract ( systemContractABI ). at ( systemContractAddress ); var balance = web3 . fromWei ( eth . getBalance ( eth . coinbase )); var stakeAmount = parseInt ( balance * 10000 ); systemContract . stake ( stakeAmount ); Vote yourself var systemContractAddress = '0x0000000000000000000000000000000000000101' ; var systemContractABI = eth . getAbiForAddress ( systemContractAddress ); systemContractABI = JSON . parse ( systemContractABI ); var systemContract = eth . contract ( systemContractABI ). at ( systemContractAddress ); systemContract . vote ([ eth . coinbase ]);","title":"Running a full node as Witness"},{"location":"becoming-a-block-producer/running-a-witness/#becoming-a-block-producer","text":"For becoming a block producer you have to get a synced node with the network. To reach to that state, let\u2019s get the needed ingredients to start our node. Let\u2019s set a folder in our system where we will store both our secrets and the data of our node. export BASE_PATH = ~/ebakus-producer mkdir -p ${ BASE_PATH } Important This doc refers on how to become a block producer on the mainnet . If you would like to experiment on testnet add the --testnet flag.","title":"Becoming a block producer"},{"location":"becoming-a-block-producer/running-a-witness/#create-an-account-for-the-block-producer","text":"","title":"Create an account for the block producer"},{"location":"becoming-a-block-producer/running-a-witness/#create-a-password-file-for-your-account","text":"It\u2019s up to you to decide how to generate the password for your account. Here you can find an example command: openssl rand -base64 32 > ${ BASE_PATH } /passwd","title":"Create a password file for your account"},{"location":"becoming-a-block-producer/running-a-witness/#create-the-account","text":"docker run --rm --name ebakus-producer \\ -v ${ BASE_PATH } :/root \\ -p 30403 :30403 \\ -p 30403 :30403/udp \\ ebakus/go-ebakus \\ account new \\ --password /root/passwd Example output Your new key was generated Public address of the key : 0 xA356eF85BB1740eC494B3c4eDA230aBd64D571F8 Path of the secret key file : / root / . ebakus / keystore / UTC --2019-12-17T13-44-28.902899300Z--a356ef85bb1740ec494b3c4eda230abd64d571f8 From the above we need to note our public address. That is 0xA356eF85BB1740eC494B3c4eDA230aBd64D571F8 in this example.","title":"Create the account"},{"location":"becoming-a-block-producer/running-a-witness/#starting-the-producer","text":"We start our producer, having opened the 30403 port in the docker for connecting to the P2P network. We then set our etherbase and password as well unlocking the account. docker run -d --name ebakus-producer \\ -v ${ BASE_PATH } :/root \\ -p 30403 :30403 \\ -p 30403 :30403/udp \\ ebakus/go-ebakus \\ --etherbase 0xA356eF85BB1740eC494B3c4eDA230aBd64D571F8 \\ --unlock 0xA356eF85BB1740eC494B3c4eDA230aBd64D571F8 \\ --password /root/passwd","title":"Starting the producer"},{"location":"becoming-a-block-producer/running-a-witness/#stopping-the-producer","text":"It is important that you properly stop a running produser. Simply killing the ebakus process, or the docker container, will probably result in a corrupted state database that will require a complete resync of the node. To avoid the constly resync, it is important to allow the producer to gracefully shutdown. We do this by sending it the SIGTERM signal. This is accomplished by the command below: docker kill --signal = SIGTERM ebakus-producer Info Stopping a producer will result in missed blocks. Read the Step down as a witness section in this guide on how to avoid this.","title":"Stopping the producer"},{"location":"becoming-a-block-producer/running-a-witness/#monitor-syncing","text":"Now we have to wait for the node to be synced. We can check the progress by attaching to the docker container like: docker exec -it ebakus-producer ebakus attach Inside the attached console we can check if we are currently syncing which has to return false . eth . syncing // -- Output -- // false And also to check if the blockNumber is the latest one in our explorer as well. eth . blockNumber","title":"Monitor syncing"},{"location":"becoming-a-block-producer/running-a-witness/#control-the-producer","text":"Once you are ready, set node active for producing. docker exec -it ebakus-producer ebakus attach miner . start () // -- Output -- // true Tip After the initial sync and being added as a witness you can add --mine flag in the docker startup script for auto mining. Also you ask docker to automatically restart when something happens --restart unless-stopped in the docker params.","title":"Control the producer"},{"location":"becoming-a-block-producer/running-a-witness/#allow-to-be-voted-as-a-witness","text":"For electing ourselves as a witness we have to send a transaction on the system contract 0x0000000000000000000000000000000000000101 . For doing so we need to attach to the docker container: docker exec -it ebakus-producer ebakus attach To set \u201c electEnable \u201d to true you must again send a transaction to the system like this: var systemContractAddress = '0x0000000000000000000000000000000000000101' ; var systemContractABI = eth . getAbiForAddress ( systemContractAddress ); systemContractABI = JSON . parse ( systemContractABI ); var systemContract = eth . contract ( systemContractABI ). at ( systemContractAddress ); systemContract . electEnable ( true ); Information on Proof of Work (PoW) For more information on PoW check here .","title":"Allow to be voted as a witness"},{"location":"becoming-a-block-producer/running-a-witness/#step-down-as-a-witness","text":"There are cases when you will need to step down from producing blocks. These include: Experiencing technical difficulties During software updates No longer wanting to participate in the Ebakus network In these cases or any other when you will not be able/willing to produce blocks, it is important that you inform the network of your intention by setting \u201c electEnable \u201d to false . Users are monitoring the network for producers that miss blocks, and you don\u2019t want to be seen as a bad performing producer possibly resulting in lost votes. Setting \u201c electEnable \u201d to false will prevent you from losing blocks while you are experiencing any difficulty. To set \u201c electEnable \u201d to false you must again send a transaction to the system like this: var systemContractAddress = '0x0000000000000000000000000000000000000101' ; var systemContractABI = eth . getAbiForAddress ( systemContractAddress ); systemContractABI = JSON . parse ( systemContractABI ); var systemContract = eth . contract ( systemContractAddress ). at ( systemContractAddress ); systemContract . electEnable ( false );","title":"Step down as a witness"},{"location":"becoming-a-block-producer/running-a-witness/#be-voted","text":"In order to produce a block you need to be in the top 100 witnesses. For attracting others to vote you, you can help the community and ask others to vote you. Tip Don\u2019t forget to vote for yourself!!! \ud83d\ude00 The easier way to vote is by visiting the Ebakus explorer statistics and use the Ebakus wallet. Although, in case you want to vote yourself from within the go-ebakus node, here is some example code. This example will stake your whole balance at the moment running the command. Stake whole balance var systemContractAddress = '0x0000000000000000000000000000000000000101' ; var systemContractABI = eth . getAbiForAddress ( systemContractAddress ); systemContractABI = JSON . parse ( systemContractABI ); var systemContract = eth . contract ( systemContractABI ). at ( systemContractAddress ); var balance = web3 . fromWei ( eth . getBalance ( eth . coinbase )); var stakeAmount = parseInt ( balance * 10000 ); systemContract . stake ( stakeAmount ); Vote yourself var systemContractAddress = '0x0000000000000000000000000000000000000101' ; var systemContractABI = eth . getAbiForAddress ( systemContractAddress ); systemContractABI = JSON . parse ( systemContractABI ); var systemContract = eth . contract ( systemContractABI ). at ( systemContractAddress ); systemContract . vote ([ eth . coinbase ]);","title":"Be voted"},{"location":"developing-applications-with-ebakus/external-node-endpoints/","text":"When building your own dApp there is a need to connect with a node in order to read and write to the Ebakus blockchain. It is adviced to run your own node for your dApp in order to perform faster and control that your service is always online. Advice Please be kind and start your own node for your dApp if you have traffic. go-ebakus node endpoints \u00b6 For smaller traffic and for ease of use we provide endpoints to the Ebakus external nodes so as you can start with. Mainnet \u00b6 Type Endpoint rpc https://rpc.ebakus.com ws wss://ws.ebakus.com Testnet \u00b6 Type Endpoint rpc https://rpc.ebakus-testnet.com ws wss://ws.ebakus-testnet.com","title":"External node endpoints"},{"location":"developing-applications-with-ebakus/external-node-endpoints/#go-ebakus-node-endpoints","text":"For smaller traffic and for ease of use we provide endpoints to the Ebakus external nodes so as you can start with.","title":"go-ebakus node endpoints"},{"location":"developing-applications-with-ebakus/external-node-endpoints/#mainnet","text":"Type Endpoint rpc https://rpc.ebakus.com ws wss://ws.ebakus.com","title":"Mainnet"},{"location":"developing-applications-with-ebakus/external-node-endpoints/#testnet","text":"Type Endpoint rpc https://rpc.ebakus-testnet.com ws wss://ws.ebakus-testnet.com","title":"Testnet"},{"location":"developing-applications-with-ebakus/gettting-started-with-ebakus-development/","text":"Getting started \u00b6 Ebakus based decentralized applications consist of two parts: the business logic that is developed through smart contracts in the solidity language and runs on the ebakus network the client logic that interfaces with the smart contract To enable developers produce highly responsive and frictionless decentralized applications that are a delight for users to use, we have created the ebakus development stack. The ebakus development stack \u00b6 The ebakus development stack consists of: the ebakus node : DPOS, 1 second blocks, ebakusDB web3-ebakus : is an extention of ethereum\u2019s popular web3 library to enable calculation of PoW and access ebakusDB the wallet-loader library : can be included on any static site and provide an interface to the ebakus blockchain through the web wallet the ebakus web wallet : is the interface to the ebakus network The ebakus development stack allows for applications that are as easy to use, as any other application built on centralized infrastructure while remaining completely decentralized (without the need to rely on hybrid models). The smart contract \u00b6 Smart contracts in the decentralized application context are the business logic and the blockchain is where they are stored and run. They are essentially the backend of the application and they are special because they: are immutable and produce deterministic results run forever cost nothing to run for the developers As we mentioned before, the ebakus node is 100% backwards compatible with ethereum . This allows you to use the vast resources available for developing smart contracts for solidity and apply everything you learn to ebakus to enjoy no fees, low latency and high throughput. Moreover ebakus extends solidity with ebakusDB a transactional decentralized Database that makes handling large datasets a breeze. You can try out examples and tutorials you find through: the ebakus version of Remix IDE that will help you write, test and deploy solidity contracts for the ebakus network our own block explorer If you already understand the basics of developing smart contracts you may find interesting this article that introduces the ebakusDB . The client logic \u00b6 The client logic on the other hand works a bit differently as the ebakus development stack utilizes the embedded wallet that drastically improves usability. Lets see just how this works in a bit more detail. The proposed way to handle client logic uses three components: the web3-ebakus : loads a web3 instance and extends it with web3 specific functions that allow you to access data stored in ebakusDB the wallet-loader library : loads the ebakus web wallet in an iframe and provides an interface between your dApp and the ebakus wallet without giving you access to your keys. This method of loading the wallet allows many dApps share the same wallet when running in the same browser Safari browser : Sharing the same wallet accross dApps is not supported (using its default settings). the ebakus web wallet hosted by a third party or yourself. Allows you to interface with the ebakus blockchain, send transactions, call contract functions and write data to the ebakusDB If you already have a dApp running on ethereum or you are following a tutorial written for ethereum this article about migrating your ethereum based dApp to ebakus will be usefull.","title":"Getting started"},{"location":"developing-applications-with-ebakus/gettting-started-with-ebakus-development/#getting-started","text":"Ebakus based decentralized applications consist of two parts: the business logic that is developed through smart contracts in the solidity language and runs on the ebakus network the client logic that interfaces with the smart contract To enable developers produce highly responsive and frictionless decentralized applications that are a delight for users to use, we have created the ebakus development stack.","title":"Getting started"},{"location":"developing-applications-with-ebakus/gettting-started-with-ebakus-development/#the-ebakus-development-stack","text":"The ebakus development stack consists of: the ebakus node : DPOS, 1 second blocks, ebakusDB web3-ebakus : is an extention of ethereum\u2019s popular web3 library to enable calculation of PoW and access ebakusDB the wallet-loader library : can be included on any static site and provide an interface to the ebakus blockchain through the web wallet the ebakus web wallet : is the interface to the ebakus network The ebakus development stack allows for applications that are as easy to use, as any other application built on centralized infrastructure while remaining completely decentralized (without the need to rely on hybrid models).","title":"The ebakus development stack"},{"location":"developing-applications-with-ebakus/gettting-started-with-ebakus-development/#the-smart-contract","text":"Smart contracts in the decentralized application context are the business logic and the blockchain is where they are stored and run. They are essentially the backend of the application and they are special because they: are immutable and produce deterministic results run forever cost nothing to run for the developers As we mentioned before, the ebakus node is 100% backwards compatible with ethereum . This allows you to use the vast resources available for developing smart contracts for solidity and apply everything you learn to ebakus to enjoy no fees, low latency and high throughput. Moreover ebakus extends solidity with ebakusDB a transactional decentralized Database that makes handling large datasets a breeze. You can try out examples and tutorials you find through: the ebakus version of Remix IDE that will help you write, test and deploy solidity contracts for the ebakus network our own block explorer If you already understand the basics of developing smart contracts you may find interesting this article that introduces the ebakusDB .","title":"The smart contract"},{"location":"developing-applications-with-ebakus/gettting-started-with-ebakus-development/#the-client-logic","text":"The client logic on the other hand works a bit differently as the ebakus development stack utilizes the embedded wallet that drastically improves usability. Lets see just how this works in a bit more detail. The proposed way to handle client logic uses three components: the web3-ebakus : loads a web3 instance and extends it with web3 specific functions that allow you to access data stored in ebakusDB the wallet-loader library : loads the ebakus web wallet in an iframe and provides an interface between your dApp and the ebakus wallet without giving you access to your keys. This method of loading the wallet allows many dApps share the same wallet when running in the same browser Safari browser : Sharing the same wallet accross dApps is not supported (using its default settings). the ebakus web wallet hosted by a third party or yourself. Allows you to interface with the ebakus blockchain, send transactions, call contract functions and write data to the ebakusDB If you already have a dApp running on ethereum or you are following a tutorial written for ethereum this article about migrating your ethereum based dApp to ebakus will be usefull.","title":"The client logic"},{"location":"developing-applications-with-ebakus/proof-of-work/","text":"Free transactions \u00b6 One of the main reasons we decided to built ebakus was to improve usability of decentralized applications. When we started looking into viable business models and ideas for dApps, we quickly found out that fees and complex resource management systems really hindered usability. The requirement for users to own an initial token balance in order to interact with decentralized applications was really hurting onboarding of new users that had no previous experience with blockchain applications and it was one of the first problems we built ebakus to solve. Blockchains today use fees in order to achieve two main goals. First, to mitigate malicious unsolicited flooding of the network with a huge number of transactions in order to affect the quality of service for normal operations, and use up storage and processing capacity. Second, to incentivise the miners or block producers as they collect those fees. Adding fees to every transaction greatly hinders the usability of a blockchain. One of our main design goal with ebakus software is to provide free transactions. We do this by solving the two aforementioned problems. We solve the incentive problem by using inflation. The block producers don\u2019t depend on the fees of transactions as the software constantly creates new ebakus coins as a reward for them. So now, we have to address the spamming of the network in order to make the inflation truly compensate for the lack of fees additionally to maintaining the quality of service. We achieve this by utilising an algorithm that uses proof of work in combination with proof of stake. The initial invention of PoW was actually for use in mitigating network denial of service. Most blockchains ended up using fees in order to make it expensive to attack the network, while killing usability and eventually failing to maintain quality of service. In ebakus the network maintains a PoW quantum value. This is the minimum work required by a non stake holder -we will come back to that- for the unit operation on the network. Each operation on the network requires to consume a number PoW quanta in order to be accepted depending on the complexity of computation, the storage requirements, etc. The block providers adjust this PoW quantum to the level that allows normal operation of the network. For example if the network is idle with very little transactions being processed, transactions will require very low PoW to be accepted. In the event someone starts spamming the network with transactions the PoW quantum will be increased so it becomes computationally expensive for him to continue doing so. However, in order to achieve quality of service for the legitimate users of the network ebakus does not operate entirely on the global PoW quantum. The global PoW quantum essentially the work quantum required by accounts holding zero amount of ebakus coins. The actual work quantum accepted is adjusted for each account as a function of its stake. Accounts that hold more ebakus coins -and hence have more stake- have a lesser PoW quantum. The PoW quantum is adjusted in a way that, at anytime, the network resources are allocated proportionally to all the stake holders sending transactions. Ebakus wallets will be able to recalculate the PoW required to send a transaction, so even in cases that the account has zero stake and the network is congested, the user experience will be smooth. Flow for PoW \u00b6 Create a transaction object Retrieve nonce for this transaction Estimate Gas needed for this transaction Get suggested difficulty for our account at current network state Calculate PoW for this transaction Tip From this point, don\u2019t change any tx properties, as they have been used for calculating the PoW. Send the transaction Sending transaction examples \u00b6 Below you can find examples of sending a simple transaction either through go-ebakus console or your dApp\u2019s web3.js. From go-ebakus console \u00b6 var tx = { from : eth . coinbase , to : '0x8f10d3a6283672ecfaeea0377d460bded489ec44' , value : web3 . toWei ( 10 ), nonce : eth . getTransactionCount ( eth . coinbase ) }; tx . gas = eth . estimateGas ( tx ); var txWithPow = eth . calculateWorkNonce ( tx , eth . suggestDifficulty ( eth . coinbase )); eth . sendTransaction ( txWithPow ); From web3.js of your dApp \u00b6 var tx = { from : '0xB2b3510C106E8e04Acfb9841e2213500167100f3' , to : '0x8f10d3a6283672ecfaeea0377d460bded489ec44' , value : web3 . toWei ( 10 ), nonce : eth . getTransactionCount ( '0xB2b3510C106E8e04Acfb9841e2213500167100f3' ) }; tx . gas = eth . estimateGas ( tx ); var txWithPow = eth . calculateWorkNonce ( tx , eth . suggestDifficulty ( '0xB2b3510C106E8e04Acfb9841e2213500167100f3' )); eth . sendTransaction ( txWithPow );","title":"Proof of Work (PoW)"},{"location":"developing-applications-with-ebakus/proof-of-work/#free-transactions","text":"One of the main reasons we decided to built ebakus was to improve usability of decentralized applications. When we started looking into viable business models and ideas for dApps, we quickly found out that fees and complex resource management systems really hindered usability. The requirement for users to own an initial token balance in order to interact with decentralized applications was really hurting onboarding of new users that had no previous experience with blockchain applications and it was one of the first problems we built ebakus to solve. Blockchains today use fees in order to achieve two main goals. First, to mitigate malicious unsolicited flooding of the network with a huge number of transactions in order to affect the quality of service for normal operations, and use up storage and processing capacity. Second, to incentivise the miners or block producers as they collect those fees. Adding fees to every transaction greatly hinders the usability of a blockchain. One of our main design goal with ebakus software is to provide free transactions. We do this by solving the two aforementioned problems. We solve the incentive problem by using inflation. The block producers don\u2019t depend on the fees of transactions as the software constantly creates new ebakus coins as a reward for them. So now, we have to address the spamming of the network in order to make the inflation truly compensate for the lack of fees additionally to maintaining the quality of service. We achieve this by utilising an algorithm that uses proof of work in combination with proof of stake. The initial invention of PoW was actually for use in mitigating network denial of service. Most blockchains ended up using fees in order to make it expensive to attack the network, while killing usability and eventually failing to maintain quality of service. In ebakus the network maintains a PoW quantum value. This is the minimum work required by a non stake holder -we will come back to that- for the unit operation on the network. Each operation on the network requires to consume a number PoW quanta in order to be accepted depending on the complexity of computation, the storage requirements, etc. The block providers adjust this PoW quantum to the level that allows normal operation of the network. For example if the network is idle with very little transactions being processed, transactions will require very low PoW to be accepted. In the event someone starts spamming the network with transactions the PoW quantum will be increased so it becomes computationally expensive for him to continue doing so. However, in order to achieve quality of service for the legitimate users of the network ebakus does not operate entirely on the global PoW quantum. The global PoW quantum essentially the work quantum required by accounts holding zero amount of ebakus coins. The actual work quantum accepted is adjusted for each account as a function of its stake. Accounts that hold more ebakus coins -and hence have more stake- have a lesser PoW quantum. The PoW quantum is adjusted in a way that, at anytime, the network resources are allocated proportionally to all the stake holders sending transactions. Ebakus wallets will be able to recalculate the PoW required to send a transaction, so even in cases that the account has zero stake and the network is congested, the user experience will be smooth.","title":"Free transactions"},{"location":"developing-applications-with-ebakus/proof-of-work/#flow-for-pow","text":"Create a transaction object Retrieve nonce for this transaction Estimate Gas needed for this transaction Get suggested difficulty for our account at current network state Calculate PoW for this transaction Tip From this point, don\u2019t change any tx properties, as they have been used for calculating the PoW. Send the transaction","title":"Flow for PoW"},{"location":"developing-applications-with-ebakus/proof-of-work/#sending-transaction-examples","text":"Below you can find examples of sending a simple transaction either through go-ebakus console or your dApp\u2019s web3.js.","title":"Sending transaction examples"},{"location":"developing-applications-with-ebakus/proof-of-work/#from-go-ebakus-console","text":"var tx = { from : eth . coinbase , to : '0x8f10d3a6283672ecfaeea0377d460bded489ec44' , value : web3 . toWei ( 10 ), nonce : eth . getTransactionCount ( eth . coinbase ) }; tx . gas = eth . estimateGas ( tx ); var txWithPow = eth . calculateWorkNonce ( tx , eth . suggestDifficulty ( eth . coinbase )); eth . sendTransaction ( txWithPow );","title":"From go-ebakus console"},{"location":"developing-applications-with-ebakus/proof-of-work/#from-web3js-of-your-dapp","text":"var tx = { from : '0xB2b3510C106E8e04Acfb9841e2213500167100f3' , to : '0x8f10d3a6283672ecfaeea0377d460bded489ec44' , value : web3 . toWei ( 10 ), nonce : eth . getTransactionCount ( '0xB2b3510C106E8e04Acfb9841e2213500167100f3' ) }; tx . gas = eth . estimateGas ( tx ); var txWithPow = eth . calculateWorkNonce ( tx , eth . suggestDifficulty ( '0xB2b3510C106E8e04Acfb9841e2213500167100f3' )); eth . sendTransaction ( txWithPow );","title":"From web3.js of your dApp"},{"location":"developing-applications-with-ebakus/running-a-local-development-node/","text":"Running a local development node \u00b6 While developing your own dApp it might be useful to run your own node. For doing this run: docker run -ti --name ebakus-dev-node \\ -v ~/ebakus:/root \\ -p 30403 :30403 \\ -p 8545 :8545 \\ ebakus/go-ebakus \\ --dev \\ --rpc --rpcaddr 0 .0.0.0 \\ --preload /root/ebakus-load.js \\ console Tip Instead of the --testnet flag, the --dev one is used. The ~/ebakus/ebakus-load.js script contains some quick access utility functions as can be the following: /* * Developer helpful functions for Ebakus node! */ /* * -- Helpful constants */ var DEV_ACCOUNTS = { producer : { address : \"0xB2b3510C106E8e04Acfb9841e2213500167100f3\" , prv : \"32883cebda1636ff41895b8425feee5622b074545e74db7091fa216d7ddb39d4\" , pass : \"Ebakus123\" // unlocked: false, }, simple : { address : \"0x8f10d3a6283672ecfaeea0377d460bded489ec44\" , prv : \"90308da4eedf50472684b0b7bcd51b55bec149a4bc7135ccfc9c87ade7efc9b5\" , pass : \"Ebakus123\" } }; /* * -------- Accounts ----------- */ // Import an account from the predefined DEV_ACCOUNTS constant function eAccountImport ( account ) { if ( personal . listAccounts . indexOf ( account . address . toLowerCase ()) > - 1 ) { return ; } personal . importRawKey ( account . prv , account . pass ); } // Unlock account function eAccountUnlock ( account ) { if ( account . unlocked ) { return true ; } // store unlocked state in DEV_ACCOUNTS account . unlocked = true ; console . log ( 'Account \"' + account . address + '\" unlocked!' ); // unlock producer account return personal . unlockAccount ( account . address , account . pass , 0 ); } // Unlock producer account function eAccountProducerUnlock () { return eAccountUnlock ( DEV_ACCOUNTS . producer ); } // Print balances for all account function eCheckAllBalances () { var totalBal = 0 ; for ( var acctNum in eth . accounts ) { var acct = eth . accounts [ acctNum ]; var acctBal = web3 . fromWei ( eth . getBalance ( acct ), \"ether\" ); totalBal += parseFloat ( acctBal ); console . log ( \"eth.accounts[\" + acctNum + \"]: \\t\" + acct + \" \\tbalance: \" + acctBal + \" ether\" ); } console . log ( \" Total balance: \" + totalBal + \" ether\" ); } /* * -------- Mining ----------- */ // Start mining function eMiner () { eAccountProducerUnlock (); // start miner return miner . start (); } /* * -------- Transactions ----------- */ // Producer send ether to simple account function eProducerSendEbakusToSimple ( amount ) { var producerAccount = DEV_ACCOUNTS . producer ; eAccountUnlock ( producerAccount ); return eth . sendTransaction ({ from : producerAccount . address , to : DEV_ACCOUNTS . simple . address , value : web3 . toWei ( amount || 0.01 , \"ether\" ) }); } function _bootstrap () { console . info ( \"JS Development helper has been loaded!\" ); // import producer account, once eAccountImport ( DEV_ACCOUNTS . producer ); // import another account, once eAccountImport ( DEV_ACCOUNTS . simple ); // loadScript('~/ebakus/scripts/another-script.js'); } // run on load _bootstrap ();","title":"Running a development node"},{"location":"developing-applications-with-ebakus/running-a-local-development-node/#running-a-local-development-node","text":"While developing your own dApp it might be useful to run your own node. For doing this run: docker run -ti --name ebakus-dev-node \\ -v ~/ebakus:/root \\ -p 30403 :30403 \\ -p 8545 :8545 \\ ebakus/go-ebakus \\ --dev \\ --rpc --rpcaddr 0 .0.0.0 \\ --preload /root/ebakus-load.js \\ console Tip Instead of the --testnet flag, the --dev one is used. The ~/ebakus/ebakus-load.js script contains some quick access utility functions as can be the following: /* * Developer helpful functions for Ebakus node! */ /* * -- Helpful constants */ var DEV_ACCOUNTS = { producer : { address : \"0xB2b3510C106E8e04Acfb9841e2213500167100f3\" , prv : \"32883cebda1636ff41895b8425feee5622b074545e74db7091fa216d7ddb39d4\" , pass : \"Ebakus123\" // unlocked: false, }, simple : { address : \"0x8f10d3a6283672ecfaeea0377d460bded489ec44\" , prv : \"90308da4eedf50472684b0b7bcd51b55bec149a4bc7135ccfc9c87ade7efc9b5\" , pass : \"Ebakus123\" } }; /* * -------- Accounts ----------- */ // Import an account from the predefined DEV_ACCOUNTS constant function eAccountImport ( account ) { if ( personal . listAccounts . indexOf ( account . address . toLowerCase ()) > - 1 ) { return ; } personal . importRawKey ( account . prv , account . pass ); } // Unlock account function eAccountUnlock ( account ) { if ( account . unlocked ) { return true ; } // store unlocked state in DEV_ACCOUNTS account . unlocked = true ; console . log ( 'Account \"' + account . address + '\" unlocked!' ); // unlock producer account return personal . unlockAccount ( account . address , account . pass , 0 ); } // Unlock producer account function eAccountProducerUnlock () { return eAccountUnlock ( DEV_ACCOUNTS . producer ); } // Print balances for all account function eCheckAllBalances () { var totalBal = 0 ; for ( var acctNum in eth . accounts ) { var acct = eth . accounts [ acctNum ]; var acctBal = web3 . fromWei ( eth . getBalance ( acct ), \"ether\" ); totalBal += parseFloat ( acctBal ); console . log ( \"eth.accounts[\" + acctNum + \"]: \\t\" + acct + \" \\tbalance: \" + acctBal + \" ether\" ); } console . log ( \" Total balance: \" + totalBal + \" ether\" ); } /* * -------- Mining ----------- */ // Start mining function eMiner () { eAccountProducerUnlock (); // start miner return miner . start (); } /* * -------- Transactions ----------- */ // Producer send ether to simple account function eProducerSendEbakusToSimple ( amount ) { var producerAccount = DEV_ACCOUNTS . producer ; eAccountUnlock ( producerAccount ); return eth . sendTransaction ({ from : producerAccount . address , to : DEV_ACCOUNTS . simple . address , value : web3 . toWei ( amount || 0.01 , \"ether\" ) }); } function _bootstrap () { console . info ( \"JS Development helper has been loaded!\" ); // import producer account, once eAccountImport ( DEV_ACCOUNTS . producer ); // import another account, once eAccountImport ( DEV_ACCOUNTS . simple ); // loadScript('~/ebakus/scripts/another-script.js'); } // run on load _bootstrap ();","title":"Running a local development node"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/","text":"Running a local testnet \u00b6 Sync to the public testnet with ebakus node \u00b6 For syncing with the testnet the easiest way is using docker. For doing this, you can follow the instructions here or use this command directly to start playing. docker run -ti --name ebakus-testnet-node \\ -v ~/ebakus:/root \\ -p 30403 :30403 \\ -p 8545 :8545 \\ ebakus/go-ebakus \\ --testnet \\ --rpc --rpcaddr 0 .0.0.0 \\ console Important All the code snippets in this page include JS code that can be run in the go-ebakus consoles\u2019 web3 version. Interact with the ebakus node \u00b6 After the node syncs with the network and you attach to it you will be able to issue commands in the console. For example: eth . getBlock ( 7 ) // -- Output -- // { // delegateDiff: [ // { // DelegateAddress: \"0x92f00e7fee2211d230afbe4099185efa3a516cbf\", // DelegateNumber: 0, // Pos: 0 // },{ // DelegateAddress: \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\", // DelegateNumber: 0, // Pos: 1 // } // ], // delegates: [ // \"0x92f00e7fee2211d230afbe4099185efa3a516cbf\", // \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\" // ], // gasLimit: 6283185, // gasUsed: 54144, // hash: \"0x24ddb825da11ee358dc5715e9114aeb5b9e2bdd9515bf77dfe90be34388a9685\", // number: 7, // parentHash: \"0x6e42c2731e7fb8b50ffebf37fa4067b3af2ada342535ea1a1e0d5ea97dcaa1e1\", // producer: \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\", // receiptsRoot: \"0x203b201c313a20355c1a137056b782c7572d3dee465e103708045cf33dbc8c95\", // size: 792, // timestamp: 1545512856, // transactions: [ // \"0xda07c8239b27a0e0f0a25ac41fb090a0efefe3321d0f3c667bc85d9d57b3e6b9\", // \"0xcde95fc9b4295c0b4836dd0b77e663f072bdac2df16fd2a97b0fd64d4e016be9\" // ], // transactionsRoot: \"0x53c7a83d6024b31b8221c55f04ae666149cdbc968ccc39d2dd1481bd0affb13f\" // } As you see the API follows the ethereum compatibility mode. The low level block structure however is different, and contains information relevant to DPOS and does not contain uncles, pow, and other ethereum related data. Using the javascript console of the Ebakus node you can deploy contracts and issue actions on existing contracts normally. Example of sending ebakus tokens: var tx = { from : eth . coinbase , to : '0x8f10d3a6283672ecfaeea0377d460bded489ec44' , value : web3 . toWei ( 10 ), nonce : eth . getTransactionCount ( eth . coinbase ) }; tx . gas = eth . estimateGas ( tx ); var txWithPow = eth . calculateWorkNonce ( tx , eth . suggestDifficulty ( eth . coinbase )); eth . sendTransaction ( txWithPow ); As you see, no gas needs to be spend, hence no gas price is set. For more information on PoW check here . Deploying your Ethereum Contracts on Ebakus \u00b6 Compile your contract solcjs --abi game.sol solcjs --bin game.sol Display the compiled code on the console more game_sol_game.abi more game_sol_game.bin Move back to our synced nodes\u2019 console and unlock your account personal . unlockAccount ( eth . coinbase ) // -- Output -- // Unlock account 0x.... // Passphrase: [ENTER PASSPHRASE] Setup abi and bytecode var myContract = eth . contract ([ CONTENTS OF ABI FILE ]) var bytecode = '0x[CONTENTS OF BIN FILE]' Tip Replace [CONTENTS OF ABI FILE] and [CONTENTS OF BIN FILE] with the outputs of the more commands that should still be open in another terminal window. Deploy var tx = { from : eth . coinbase , data : bytecode , nonce : eth . getTransactionCount ( eth . coinbase ) }; // add constructor args, if needed // tx.data = contract.getData(arg1, arg2, tx); tx . gas = eth . estimateGas ( tx ); var txWithPow = eth . calculateWorkNonce ( tx , eth . suggestDifficulty ( eth . coinbase )); var game = myContract . new ( txWithPow ) Interact with contract game . playMove ( 'forward' )","title":"Running a local testnet"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#running-a-local-testnet","text":"","title":"Running a local testnet"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#sync-to-the-public-testnet-with-ebakus-node","text":"For syncing with the testnet the easiest way is using docker. For doing this, you can follow the instructions here or use this command directly to start playing. docker run -ti --name ebakus-testnet-node \\ -v ~/ebakus:/root \\ -p 30403 :30403 \\ -p 8545 :8545 \\ ebakus/go-ebakus \\ --testnet \\ --rpc --rpcaddr 0 .0.0.0 \\ console Important All the code snippets in this page include JS code that can be run in the go-ebakus consoles\u2019 web3 version.","title":"Sync to the public testnet with ebakus node"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#interact-with-the-ebakus-node","text":"After the node syncs with the network and you attach to it you will be able to issue commands in the console. For example: eth . getBlock ( 7 ) // -- Output -- // { // delegateDiff: [ // { // DelegateAddress: \"0x92f00e7fee2211d230afbe4099185efa3a516cbf\", // DelegateNumber: 0, // Pos: 0 // },{ // DelegateAddress: \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\", // DelegateNumber: 0, // Pos: 1 // } // ], // delegates: [ // \"0x92f00e7fee2211d230afbe4099185efa3a516cbf\", // \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\" // ], // gasLimit: 6283185, // gasUsed: 54144, // hash: \"0x24ddb825da11ee358dc5715e9114aeb5b9e2bdd9515bf77dfe90be34388a9685\", // number: 7, // parentHash: \"0x6e42c2731e7fb8b50ffebf37fa4067b3af2ada342535ea1a1e0d5ea97dcaa1e1\", // producer: \"0x4ed2aca4f9b3ee904ff44f03e91fde90829a8381\", // receiptsRoot: \"0x203b201c313a20355c1a137056b782c7572d3dee465e103708045cf33dbc8c95\", // size: 792, // timestamp: 1545512856, // transactions: [ // \"0xda07c8239b27a0e0f0a25ac41fb090a0efefe3321d0f3c667bc85d9d57b3e6b9\", // \"0xcde95fc9b4295c0b4836dd0b77e663f072bdac2df16fd2a97b0fd64d4e016be9\" // ], // transactionsRoot: \"0x53c7a83d6024b31b8221c55f04ae666149cdbc968ccc39d2dd1481bd0affb13f\" // } As you see the API follows the ethereum compatibility mode. The low level block structure however is different, and contains information relevant to DPOS and does not contain uncles, pow, and other ethereum related data. Using the javascript console of the Ebakus node you can deploy contracts and issue actions on existing contracts normally. Example of sending ebakus tokens: var tx = { from : eth . coinbase , to : '0x8f10d3a6283672ecfaeea0377d460bded489ec44' , value : web3 . toWei ( 10 ), nonce : eth . getTransactionCount ( eth . coinbase ) }; tx . gas = eth . estimateGas ( tx ); var txWithPow = eth . calculateWorkNonce ( tx , eth . suggestDifficulty ( eth . coinbase )); eth . sendTransaction ( txWithPow ); As you see, no gas needs to be spend, hence no gas price is set. For more information on PoW check here .","title":"Interact with the ebakus node"},{"location":"developing-applications-with-ebakus/running-a-local-testnet/#deploying-your-ethereum-contracts-on-ebakus","text":"Compile your contract solcjs --abi game.sol solcjs --bin game.sol Display the compiled code on the console more game_sol_game.abi more game_sol_game.bin Move back to our synced nodes\u2019 console and unlock your account personal . unlockAccount ( eth . coinbase ) // -- Output -- // Unlock account 0x.... // Passphrase: [ENTER PASSPHRASE] Setup abi and bytecode var myContract = eth . contract ([ CONTENTS OF ABI FILE ]) var bytecode = '0x[CONTENTS OF BIN FILE]' Tip Replace [CONTENTS OF ABI FILE] and [CONTENTS OF BIN FILE] with the outputs of the more commands that should still be open in another terminal window. Deploy var tx = { from : eth . coinbase , data : bytecode , nonce : eth . getTransactionCount ( eth . coinbase ) }; // add constructor args, if needed // tx.data = contract.getData(arg1, arg2, tx); tx . gas = eth . estimateGas ( tx ); var txWithPow = eth . calculateWorkNonce ( tx , eth . suggestDifficulty ( eth . coinbase )); var game = myContract . new ( txWithPow ) Interact with contract game . playMove ( 'forward' )","title":"Deploying your Ethereum Contracts on Ebakus"},{"location":"developing-applications-with-ebakus/system-contract/","text":"The system contract adds support for fundamental actions needed by the system as a native contract. This contract supports actions like stake/unstake, vote/unvote, as well storing/retrieving the ABI for developers owned contracts. System contract address : 0x0000000000000000000000000000000000000101 . In order to use this contract, first and foremost you have to know the systems\u2019 contract ABI. You can get this: using web3.js web3 . eth . getAbiForAddress ( '0x0000000000000000000000000000000000000101' ) . then ( function ( systemContractABIString ) { const systemContractABI = JSON . parse ( systemContractABIString ) }) either copy/paste it from here by calling the getAbiForAddress on the system contract itself with code similar to this gist by fetching it from our Explorer API curl https://explorer-api.ebakus.com/abi/0x0000000000000000000000000000000000000101 Example on how to use the system contract Web3.js var systemContractAddress = '0x0000000000000000000000000000000000000101' ; web3 . eth . getAbiForAddress ( systemContractAddress ) . then ( function ( systemContractABIString ) { const systemContractABI = JSON . parse ( systemContractABIString ) var systemContract = new web3 . eth . Contract ( systemContractABI , systemContractAddress ); var account = '0x...' ; var stakeAmount = 3 * 10000 ; // 3 EBK var tx = { from : account , to : systemContractAddress , data : systemContract . methods . stake ( stakeAmount ). encodeABI () } web3 . eth . estimateGas ( tx ) . then ( function ( gas ) { tx . gas = gas return web3 . eth . suggestDifficulty ( account ) }) . then ( function ( difficulty ) { return web3 . eth . calculateWorkForTransaction ( tx , difficulty ) }) . then ( function ( txWithPow ) { return web3 . eth . sendTransaction ( txWithPow ) }) . then ( function ( receipt ) { console . log ( 'Tx receipt' , receipt ) }) // or // systemContract.methods.stake(stakeAmount).send({from: account}) // .then(function (receipt) { // console.log('Tx receipt', receipt) // }) }) go-ebakus console var systemContractAddress = '0x0000000000000000000000000000000000000101' ; var systemContractABI = eth . getAbiForAddress ( systemContractAddress ); systemContractABI = JSON . parse ( systemContractABI ); var systemContract = eth . contract ( systemContractABI ). at ( systemContractAddress ); var balance = web3 . fromWei ( eth . getBalance ( eth . coinbase )); var stakeAmount = parseInt ( balance * 10000 ); systemContract . stake ( stakeAmount ); Methods documentation \u00b6 stake(uint64) \u00b6 Stakes EBK amount for account, which can be used for voting and for needing less Proof of Work for sending a transaction to the network. Staked amount remains to the user account and is not being taken by the system. At any point user can unstake it and use it. Voting With regards voting, all voted producers (up to 20) will receive the whole EBK stake evenly. Tip While staking and in case user has EBK pending for unstaking, then the system contract will first use the unstaking EBK before using the liquid amount from your wallet. getStaked() uint64 \u00b6 Retrieve the staked amount for current user. unstake(uint64) \u00b6 Unstake existing staked EBK amount for account. Unstaking will hold the EBK tokens from being available to the account for 3 days until they mature. Voting If wallet has voted before and unstakes the whole amount, votes will not be removed, but will only be disabled. The next time wallet will stake EBK, votes will be re-enabled. claim() \u00b6 For unstaked EBK and after they mature within 3 days , user has to call claim method in order EBK are available in the wallet as liquid balance. vote(address[]) \u00b6 In order for the system to operate normally and be performant, users has to vote the most trustful and powerfull producers. For doing so, vote has to be used. It accepts and array of account addresses. A wallet can vote up to 20 producers. Requirement Account must have staked amount. Tip Every time vote gets called, it has to set all the voted addresses and not only the new ones. unvote() \u00b6 This command will unvote all the producers already voted. electEnable(bool) \u00b6 When a witness wants to set its node active for producing, she has call the electEnable command in order to be active. It\u2019s very important that the producer remains online and is synced the whole time. Danger If the producer has issues or wants to go in maintenance mode, she has to call `electEnable(false) beforehand. Once finished, she can enable the producer again without losing the ranking. storeAbiForAddress(address,string) \u00b6 For the ecosystem to work better (explorers, wallets) and so as anyone can use the deployed contracts, other developers has to know the contract ABI. For this reason the system contract allows the developer to upload the contract ABI to the chain. It is suggested to happen immediatelly after the contract deploy. Warning This action can happen only once. The ABI of a contract can\u2019t be changed once uploaded. getAbiForAddress(address) string \u00b6 In order to be able to call a contract, its ABI is needed, for this reason Ebakus allows to fetch a contract ABI, if available. The response will be a JSON string.","title":"System contract"},{"location":"developing-applications-with-ebakus/system-contract/#methods-documentation","text":"","title":"Methods documentation"},{"location":"developing-applications-with-ebakus/system-contract/#stakeuint64","text":"Stakes EBK amount for account, which can be used for voting and for needing less Proof of Work for sending a transaction to the network. Staked amount remains to the user account and is not being taken by the system. At any point user can unstake it and use it. Voting With regards voting, all voted producers (up to 20) will receive the whole EBK stake evenly. Tip While staking and in case user has EBK pending for unstaking, then the system contract will first use the unstaking EBK before using the liquid amount from your wallet.","title":"stake(uint64)"},{"location":"developing-applications-with-ebakus/system-contract/#getstaked-uint64","text":"Retrieve the staked amount for current user.","title":"getStaked() uint64"},{"location":"developing-applications-with-ebakus/system-contract/#unstakeuint64","text":"Unstake existing staked EBK amount for account. Unstaking will hold the EBK tokens from being available to the account for 3 days until they mature. Voting If wallet has voted before and unstakes the whole amount, votes will not be removed, but will only be disabled. The next time wallet will stake EBK, votes will be re-enabled.","title":"unstake(uint64)"},{"location":"developing-applications-with-ebakus/system-contract/#claim","text":"For unstaked EBK and after they mature within 3 days , user has to call claim method in order EBK are available in the wallet as liquid balance.","title":"claim()"},{"location":"developing-applications-with-ebakus/system-contract/#voteaddress","text":"In order for the system to operate normally and be performant, users has to vote the most trustful and powerfull producers. For doing so, vote has to be used. It accepts and array of account addresses. A wallet can vote up to 20 producers. Requirement Account must have staked amount. Tip Every time vote gets called, it has to set all the voted addresses and not only the new ones.","title":"vote(address[])"},{"location":"developing-applications-with-ebakus/system-contract/#unvote","text":"This command will unvote all the producers already voted.","title":"unvote()"},{"location":"developing-applications-with-ebakus/system-contract/#electenablebool","text":"When a witness wants to set its node active for producing, she has call the electEnable command in order to be active. It\u2019s very important that the producer remains online and is synced the whole time. Danger If the producer has issues or wants to go in maintenance mode, she has to call `electEnable(false) beforehand. Once finished, she can enable the producer again without losing the ranking.","title":"electEnable(bool)"},{"location":"developing-applications-with-ebakus/system-contract/#storeabiforaddressaddressstring","text":"For the ecosystem to work better (explorers, wallets) and so as anyone can use the deployed contracts, other developers has to know the contract ABI. For this reason the system contract allows the developer to upload the contract ABI to the chain. It is suggested to happen immediatelly after the contract deploy. Warning This action can happen only once. The ABI of a contract can\u2019t be changed once uploaded.","title":"storeAbiForAddress(address,string)"},{"location":"developing-applications-with-ebakus/system-contract/#getabiforaddressaddress-string","text":"In order to be able to call a contract, its ABI is needed, for this reason Ebakus allows to fetch a contract ABI, if available. The response will be a JSON string.","title":"getAbiForAddress(address) string"},{"location":"developing-applications-with-ebakus/quick-guides/migrating-your-ethereum-d-app-to-ebakus/","text":"Migrating your dApp from ethereum to ebakus \u00b6 While ethereum has been a pioneer in the blockchain space by enabling dApp development through smart contracts, nowadays dApps built on ethereum are decreasing in popularity and dApp developers are researching other platforms like EOS and Tron, that reduce the latency and throughput problem found in Ethereum while improving on accessibility. On this article we propose an alternative solution to Ethereum, EOS and Tron called ebakus, that further improves throughput and does leaps in terms of accessibility and usability. The best thing about ebakus is that it\u2019s pretty forward to migrate your ethereum dApp to, or start developing a new dApp from scratch if you have prior experience with Ethereum. You can read more about ebakus here and check how it compares as a platform to ethereum and EOS here . This article will focus on onboarding ethereum developers to ebakus and will also act as a guide on how to migrate your dApp to ebakus. Developing on ebakus for ethereum developers \u00b6 To remove friction for Ethereum devs, we designed ebakus to keep the ebakus node API to be the same as go-ethereum\u2019s ( geth ) and to also be compatible with web3. The only substantial difference is that in order to send transactions through web3.js you need to use our web3-ebakus wrapper that extends it with the functions needed to calculate the POW. This means that dev tools built for ethereum\u2019s geth (like truffle) are also compatible with ebakus\u2019 node and dApps that use web3 (web3 version >1.x) to interface with their smart contracts are plug and play with ebakus. Improving accessibility and usability with ebakus\u2019 web wallet \u00b6 To further remove friction with ebakus, we have implemented a web wallet in the form of a JS library. This wallet can be embedded inside a dApp and along with the \u201cfree\u201d transactions model of ebakus, they provide a transparent (as far as the users are concerned) interface to the ebakus blockchain. The moment your dApp loads, the user is ready to interact with the blockchain. To further improve experience we went a step further and developed a wallet loader library that creates an iframe and loads a hosted version of the ebakus web wallet in it. This way multiple dApps can share the same wallet drastically improving the UX while also strengthening security. After downloading or installing it through npm , the wallet-loader library from here all you have to do to load it in your project is to add the following in your dApp\u2019s html: < body > <!-- Body content... --> < script type = \u201dtext/javascript\u201d src = \u201dwallet-loader.min.js\u201d > </ script > </ body > If needed, you can then init the wallet with custom tokens with the following: < script > /* you can listen for `ebakusLoaded` event in order to know when wallet is ready */ window . addEventListener ( 'ebakusLoaded' , ( ev ) => { console . warn ( 'Ebakus Wallet loaded!' ) /* loading custom token to wallet */ ebakusWallet . init ({ tokens : [{ contract_address : '0xa679d48c57320e9f0eadb043c3ea3f8dcd97ed01' , symbol : 'SIM' , decimals : 18 , }] }) }) /* Additional code */ < /script> After loading it, you can easily interface with the wallet through its API . Further optimizations \u00b6 You may further want to optimize your dApp\u2019s code to take advantage of ebakus\u2019 lower latency (1 sec) and to leverage ebakusDB. EbakusDB allows you to use schema defined tables, with indexes that allows handling large datasets with ease. EbakusDB integration to EVM is already implemented and active in our testnet and an article describing how you can utilize it, is in the works. If you feel adventurous feel free to check out this indie leaderboard repository where we implement a leaderboard-achievements solution running completely decentralized on ebakus, leveraging ebakusDB. You can also further study a real world migration example of an ethereum dApp to ebakus here .","title":"Migrating your ethereum dApp"},{"location":"developing-applications-with-ebakus/quick-guides/migrating-your-ethereum-d-app-to-ebakus/#migrating-your-dapp-from-ethereum-to-ebakus","text":"While ethereum has been a pioneer in the blockchain space by enabling dApp development through smart contracts, nowadays dApps built on ethereum are decreasing in popularity and dApp developers are researching other platforms like EOS and Tron, that reduce the latency and throughput problem found in Ethereum while improving on accessibility. On this article we propose an alternative solution to Ethereum, EOS and Tron called ebakus, that further improves throughput and does leaps in terms of accessibility and usability. The best thing about ebakus is that it\u2019s pretty forward to migrate your ethereum dApp to, or start developing a new dApp from scratch if you have prior experience with Ethereum. You can read more about ebakus here and check how it compares as a platform to ethereum and EOS here . This article will focus on onboarding ethereum developers to ebakus and will also act as a guide on how to migrate your dApp to ebakus.","title":"Migrating your dApp from ethereum to ebakus"},{"location":"developing-applications-with-ebakus/quick-guides/migrating-your-ethereum-d-app-to-ebakus/#developing-on-ebakus-for-ethereum-developers","text":"To remove friction for Ethereum devs, we designed ebakus to keep the ebakus node API to be the same as go-ethereum\u2019s ( geth ) and to also be compatible with web3. The only substantial difference is that in order to send transactions through web3.js you need to use our web3-ebakus wrapper that extends it with the functions needed to calculate the POW. This means that dev tools built for ethereum\u2019s geth (like truffle) are also compatible with ebakus\u2019 node and dApps that use web3 (web3 version >1.x) to interface with their smart contracts are plug and play with ebakus.","title":"Developing on ebakus for ethereum developers"},{"location":"developing-applications-with-ebakus/quick-guides/migrating-your-ethereum-d-app-to-ebakus/#improving-accessibility-and-usability-with-ebakus-web-wallet","text":"To further remove friction with ebakus, we have implemented a web wallet in the form of a JS library. This wallet can be embedded inside a dApp and along with the \u201cfree\u201d transactions model of ebakus, they provide a transparent (as far as the users are concerned) interface to the ebakus blockchain. The moment your dApp loads, the user is ready to interact with the blockchain. To further improve experience we went a step further and developed a wallet loader library that creates an iframe and loads a hosted version of the ebakus web wallet in it. This way multiple dApps can share the same wallet drastically improving the UX while also strengthening security. After downloading or installing it through npm , the wallet-loader library from here all you have to do to load it in your project is to add the following in your dApp\u2019s html: < body > <!-- Body content... --> < script type = \u201dtext/javascript\u201d src = \u201dwallet-loader.min.js\u201d > </ script > </ body > If needed, you can then init the wallet with custom tokens with the following: < script > /* you can listen for `ebakusLoaded` event in order to know when wallet is ready */ window . addEventListener ( 'ebakusLoaded' , ( ev ) => { console . warn ( 'Ebakus Wallet loaded!' ) /* loading custom token to wallet */ ebakusWallet . init ({ tokens : [{ contract_address : '0xa679d48c57320e9f0eadb043c3ea3f8dcd97ed01' , symbol : 'SIM' , decimals : 18 , }] }) }) /* Additional code */ < /script> After loading it, you can easily interface with the wallet through its API .","title":"Improving accessibility and usability with ebakus\u2019 web wallet"},{"location":"developing-applications-with-ebakus/quick-guides/migrating-your-ethereum-d-app-to-ebakus/#further-optimizations","text":"You may further want to optimize your dApp\u2019s code to take advantage of ebakus\u2019 lower latency (1 sec) and to leverage ebakusDB. EbakusDB allows you to use schema defined tables, with indexes that allows handling large datasets with ease. EbakusDB integration to EVM is already implemented and active in our testnet and an article describing how you can utilize it, is in the works. If you feel adventurous feel free to check out this indie leaderboard repository where we implement a leaderboard-achievements solution running completely decentralized on ebakus, leveraging ebakusDB. You can also further study a real world migration example of an ethereum dApp to ebakus here .","title":"Further optimizations"},{"location":"developing-applications-with-ebakus/quick-guides/using-ebakus-db/","text":"Using ebakusDB in Solidity \u00b6 Introduction \u00b6 Each smart contract in ebakus has its own schema defined database (ESDD). This database can support any number of tables with typed fields and indexes. A smart contract is able to perform the following operations on the data: Create/Drop tables Create/Drop indexes on specific fields Retrieve/update/delete single or multiple rows of data Do ordered range queries on these data The ebakus software makes sure that the data are stored in such a way in order to support the above operations in the most efficient way. The smart contract should not need to implement most common query types by itself. The EbakusDB layer is providing to the ebakus blockchain a very fast database layer that supports O(1) time and space complexity snapshots. This is essential to the operation of a blockchain system that has requirements for querying old block states. The database achieves high performance by being aware of the transactional log functionality that the layer above it is using and not reimplementing it itself. Therefore achieving ACID compliance without sacrificing performance. Smart contracts deployed in Ethereum compatibility mode will not be able to make use of the ESDD, hence will not be able to benefit from the extra functionality and performance. How to install \u00b6 Truffle Installation \u00b6 First install truffle via npm using npm install -g truffle . version 5.0.0 , at the time of writting this page Please visit Truffle\u2019s installation guide for further information and requirements. EbakusDB library linking \u00b6 This process will allow you to both link your contract to the current on-chain library as well as deploy it in your local environment for development. Place the EbakusDB.sol file in your truffle contracts/ directory. Place the EbakusDB.json file in your truffle build/contracts/ directory. Amend the deployment.js file in your truffle migrations/ directory as follows: var EbakusDB = artifacts . require ( 'EbakusDB' ); var YourContract = artifacts . require ( \"./YourContract.sol\" ); module . exports = function ( deployer ) { deployer . deploy ( EbakusDB , { overwrite : false }); deployer . link ( EbakusDB , YourContract ); deployer . deploy ( YourContract ); }; Note The .link() function should be called before you .deploy(YourStandardTokenContract) . Also, be sure to include the {overwrite: false} when writing the deployer i.e. .deploy(EbakusDB, {overwrite: false}) . This prevents deploying the library onto the main network at your cost and uses the library already on the blockchain. The function should still be called however because it allows you to use it in your development environment. Usage Example \u00b6 You can read about available EbakusDB methods and their documentation inline here . You can find an example contract using the EbakusDB here . pragma solidity ^ 0.5.0 ; import \"./EbakusDB.sol\" ; contract Example { string TableName = \"Users\" ; struct User { uint64 Id ; string Name ; string Pass ; } constructor () public { string memory tablesAbi = '[{\"type\":\"table\",\"name\":\"Users\",\"inputs\":[{\"name\":\"Id\",\"type\":\"uint64\"},{\"name\":\"Name\",\"type\":\"string\"},{\"name\":\"Pass\",\"type\":\"string\"}]}]' ; EbakusDB . createTable ( TableName , \"Name\" , tablesAbi ); } function main () external { // Insert entry User memory u = User ( 1 , \"Harry\" , \"123\" ); bytes memory input = abi . encode ( u . Id , u . Name , u . Pass ); EbakusDB . insertObj ( TableName , input ); // Get back entry User memory u1 ; bytes memory out = EbakusDB . get ( TableName , \"Name\" , \"Harry\" ); ( u1 . Id , u1 . Name , u1 . Pass ) = abi . decode ( out , ( uint64 , string , string )); } // more code }","title":"Using ebakusDB"},{"location":"developing-applications-with-ebakus/quick-guides/using-ebakus-db/#using-ebakusdb-in-solidity","text":"","title":"Using ebakusDB in Solidity"},{"location":"developing-applications-with-ebakus/quick-guides/using-ebakus-db/#introduction","text":"Each smart contract in ebakus has its own schema defined database (ESDD). This database can support any number of tables with typed fields and indexes. A smart contract is able to perform the following operations on the data: Create/Drop tables Create/Drop indexes on specific fields Retrieve/update/delete single or multiple rows of data Do ordered range queries on these data The ebakus software makes sure that the data are stored in such a way in order to support the above operations in the most efficient way. The smart contract should not need to implement most common query types by itself. The EbakusDB layer is providing to the ebakus blockchain a very fast database layer that supports O(1) time and space complexity snapshots. This is essential to the operation of a blockchain system that has requirements for querying old block states. The database achieves high performance by being aware of the transactional log functionality that the layer above it is using and not reimplementing it itself. Therefore achieving ACID compliance without sacrificing performance. Smart contracts deployed in Ethereum compatibility mode will not be able to make use of the ESDD, hence will not be able to benefit from the extra functionality and performance.","title":"Introduction"},{"location":"developing-applications-with-ebakus/quick-guides/using-ebakus-db/#how-to-install","text":"","title":"How to install"},{"location":"developing-applications-with-ebakus/quick-guides/using-ebakus-db/#truffle-installation","text":"First install truffle via npm using npm install -g truffle . version 5.0.0 , at the time of writting this page Please visit Truffle\u2019s installation guide for further information and requirements.","title":"Truffle Installation"},{"location":"developing-applications-with-ebakus/quick-guides/using-ebakus-db/#ebakusdb-library-linking","text":"This process will allow you to both link your contract to the current on-chain library as well as deploy it in your local environment for development. Place the EbakusDB.sol file in your truffle contracts/ directory. Place the EbakusDB.json file in your truffle build/contracts/ directory. Amend the deployment.js file in your truffle migrations/ directory as follows: var EbakusDB = artifacts . require ( 'EbakusDB' ); var YourContract = artifacts . require ( \"./YourContract.sol\" ); module . exports = function ( deployer ) { deployer . deploy ( EbakusDB , { overwrite : false }); deployer . link ( EbakusDB , YourContract ); deployer . deploy ( YourContract ); }; Note The .link() function should be called before you .deploy(YourStandardTokenContract) . Also, be sure to include the {overwrite: false} when writing the deployer i.e. .deploy(EbakusDB, {overwrite: false}) . This prevents deploying the library onto the main network at your cost and uses the library already on the blockchain. The function should still be called however because it allows you to use it in your development environment.","title":"EbakusDB library linking"},{"location":"developing-applications-with-ebakus/quick-guides/using-ebakus-db/#usage-example","text":"You can read about available EbakusDB methods and their documentation inline here . You can find an example contract using the EbakusDB here . pragma solidity ^ 0.5.0 ; import \"./EbakusDB.sol\" ; contract Example { string TableName = \"Users\" ; struct User { uint64 Id ; string Name ; string Pass ; } constructor () public { string memory tablesAbi = '[{\"type\":\"table\",\"name\":\"Users\",\"inputs\":[{\"name\":\"Id\",\"type\":\"uint64\"},{\"name\":\"Name\",\"type\":\"string\"},{\"name\":\"Pass\",\"type\":\"string\"}]}]' ; EbakusDB . createTable ( TableName , \"Name\" , tablesAbi ); } function main () external { // Insert entry User memory u = User ( 1 , \"Harry\" , \"123\" ); bytes memory input = abi . encode ( u . Id , u . Name , u . Pass ); EbakusDB . insertObj ( TableName , input ); // Get back entry User memory u1 ; bytes memory out = EbakusDB . get ( TableName , \"Name\" , \"Harry\" ); ( u1 . Id , u1 . Name , u1 . Pass ) = abi . decode ( out , ( uint64 , string , string )); } // more code }","title":"Usage Example"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-node/","text":"Ebakus node - Go Ebakus \u00b6 Official Ebakus protocol implementation in Go. Running ebakus node \u00b6 By far the most common scenario is people wanting to simply interact with the Ebakus network: create accounts; transfer funds; deploy and interact with contracts. One of the quickest ways to get Ebakus up and running on your machine is through the Docker images of the ebakus node. ebakus/go-ebakus:latest is the latest development version of Ebakus (default) ebakus/go-ebakus:{version} is the stable version of Ebakus at a specific version number To pull an image and start a node, run these commands: docker run -d --name ebakus-node \\ -v ~/ebakus:/root \\ -p 30403 :30403 \\ ebakus/go-ebakus It will create a persistent volume in your home directory (~/ebakus) for saving your blockchain. Do not forget --rpc --rpcaddr 0.0.0.0 , if you want to access RPC from other containers and/or hosts. By default, ebakus binds to the local interface and RPC endpoints is not accessible from the outside. The image has the following ports automatically exposed: 8545 TCP, used by the HTTP based JSON RPC API 8546 TCP, used by the WebSocket based JSON RPC API 8547 TCP, used by the GraphQL API 30403 TCP and UDP, used by the P2P protocol running the network Note If you are running an Ebakus client inside a Docker container, you should mount a data volume as the client\u2019s data directory (located at /root/.ebakus inside the container) to ensure that downloaded data is preserved between restarts and/or container life-cycles. Access the ebakus node running in docker container \u00b6 Now that the ebakus node is up and running, and in order to get access to its built-in interactive JavaScript console we have to run: docker exec -it ebakus-node ebakus --testnet attach Built-in interactive JavaScript console Within the console you can invoke all official web3 methods as well as Ebakus\u2019 own management APIs. Sync with the Ebakus test network \u00b6 Transitioning towards developers, if you\u2019d like to play around with creating Ebakus contracts, you almost certainly would like to do that without any real money involved until you get the hang of the entire system. In other words, instead of attaching to the main network, you want to join the test network with your node, which is fully equivalent to the main network, but with play-EBK only. In order to achive this we have to add --testnet flag after our ebakus/go-ebakus in the start up command . Like so: docker run -d --name ebakus-node \\ -v ~/ebakus:/root \\ -p 30403 :30403 \\ ebakus/go-ebakus \\ --testnet Tip Don\u2019t forget to add the --testnet flag in the attach command also. Note Although there are some internal protective measures to prevent transactions from crossing over between the main network and test network, you should make sure to always use separate accounts for play-money and real-money. Unless you manually move accounts, ebakus will by default correctly separate the two networks and will not make any accounts available between them. Programatically interfacing ebakus nodes \u00b6 As a developer, sooner rather than later you\u2019ll want to start interacting with ebakus and the Ebakus network via your own programs and not manually through the console. To aid this, ebakus has built-in support for a JSON-RPC based APIs. These can be exposed via HTTP, WebSockets and IPC (UNIX sockets on UNIX based platforms, and named pipes on Windows). The IPC interface is enabled by default and exposes all the APIs supported by ebakus , whereas the HTTP,WS and GraphQL interfaces need to manually be enabled and only expose a subset of APIs due to security reasons. These can be turned on/off and configured as you\u2019d expect. HTTP based JSON-RPC API options: --rpc Enable the HTTP-RPC server --rpcaddr HTTP-RPC server listening interface (default: localhost ) --rpcport HTTP-RPC server listening port (default: 8545 ) --rpcapi API\u2019s offered over the HTTP-RPC interface (default: db,dpos,eth,net,web3 ) --rpccorsdomain Comma separated list of domains from which to accept cross origin requests (browser enforced) --rpcvhosts Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts * wildcard. (default: localhost ) --ws Enable the WS-RPC server --wsaddr WS-RPC server listening interface (default: localhost ) --wsport WS-RPC server listening port (default: 8546 ) --wsapi API\u2019s offered over the WS-RPC interface (default: db,dpos,eth,net,web3 ) --wsorigins Origins from which to accept websockets requests --ipcdisable Disable the IPC-RPC server --ipcapi API\u2019s offered over the IPC-RPC interface (default: admin,db,debug,dpos,eth,miner,net,personal,shh,txpool,web3 ) --ipcpath Filename for IPC socket/pipe within the datadir (explicit paths escape it) --graphql Enable the GraphQL server --graphql.addr GraphQL server listening interface (default: localhost ) --graphql.port GraphQL server listening port (default: 8547 ) --graphql.corsdomain Comma separated list of domains from which to accept cross origin requests (browser enforced) --graphql.vhosts Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts * wildcard. (default: localhost ) You\u2019ll need to use your own programming environments\u2019 capabilities (libraries, tools, etc) to connect via HTTP, WS or IPC to a ebakus node configured with the above flags and you\u2019ll need to speak JSON-RPC on all transports. You can reuse the same connection for multiple requests! Tip Please understand the security implications of opening up an HTTP/WS/GraphQL based transport before doing so! Hackers on the internet are actively trying to subvert Ebakus nodes with exposed APIs! Further, all browser tabs can access locally running web servers, so malicious web pages could try to subvert locally available APIs! Example Here is an example command for starting up a node on testnet with opened RPC/WS transports and attached to the internal node console. docker run -ti --name ebakus-testnet-node \\ -v ~/ebakus:/root \\ -p 30403 :30403 \\ -p 8545 :8545 \\ -p 8546 :8546 \\ ebakus/go-ebakus \\ --testnet \\ --rpc --rpcaddr 0 .0.0.0 \\ --ws --wsaddr 0 .0.0.0 \\ console","title":"Ebakus node"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-node/#ebakus-node-go-ebakus","text":"Official Ebakus protocol implementation in Go.","title":"Ebakus node - Go Ebakus"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-node/#running-ebakus-node","text":"By far the most common scenario is people wanting to simply interact with the Ebakus network: create accounts; transfer funds; deploy and interact with contracts. One of the quickest ways to get Ebakus up and running on your machine is through the Docker images of the ebakus node. ebakus/go-ebakus:latest is the latest development version of Ebakus (default) ebakus/go-ebakus:{version} is the stable version of Ebakus at a specific version number To pull an image and start a node, run these commands: docker run -d --name ebakus-node \\ -v ~/ebakus:/root \\ -p 30403 :30403 \\ ebakus/go-ebakus It will create a persistent volume in your home directory (~/ebakus) for saving your blockchain. Do not forget --rpc --rpcaddr 0.0.0.0 , if you want to access RPC from other containers and/or hosts. By default, ebakus binds to the local interface and RPC endpoints is not accessible from the outside. The image has the following ports automatically exposed: 8545 TCP, used by the HTTP based JSON RPC API 8546 TCP, used by the WebSocket based JSON RPC API 8547 TCP, used by the GraphQL API 30403 TCP and UDP, used by the P2P protocol running the network Note If you are running an Ebakus client inside a Docker container, you should mount a data volume as the client\u2019s data directory (located at /root/.ebakus inside the container) to ensure that downloaded data is preserved between restarts and/or container life-cycles.","title":"Running ebakus node"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-node/#access-the-ebakus-node-running-in-docker-container","text":"Now that the ebakus node is up and running, and in order to get access to its built-in interactive JavaScript console we have to run: docker exec -it ebakus-node ebakus --testnet attach Built-in interactive JavaScript console Within the console you can invoke all official web3 methods as well as Ebakus\u2019 own management APIs.","title":"Access the ebakus node running in docker container"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-node/#sync-with-the-ebakus-test-network","text":"Transitioning towards developers, if you\u2019d like to play around with creating Ebakus contracts, you almost certainly would like to do that without any real money involved until you get the hang of the entire system. In other words, instead of attaching to the main network, you want to join the test network with your node, which is fully equivalent to the main network, but with play-EBK only. In order to achive this we have to add --testnet flag after our ebakus/go-ebakus in the start up command . Like so: docker run -d --name ebakus-node \\ -v ~/ebakus:/root \\ -p 30403 :30403 \\ ebakus/go-ebakus \\ --testnet Tip Don\u2019t forget to add the --testnet flag in the attach command also. Note Although there are some internal protective measures to prevent transactions from crossing over between the main network and test network, you should make sure to always use separate accounts for play-money and real-money. Unless you manually move accounts, ebakus will by default correctly separate the two networks and will not make any accounts available between them.","title":"Sync with the Ebakus test network"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-node/#programatically-interfacing-ebakus-nodes","text":"As a developer, sooner rather than later you\u2019ll want to start interacting with ebakus and the Ebakus network via your own programs and not manually through the console. To aid this, ebakus has built-in support for a JSON-RPC based APIs. These can be exposed via HTTP, WebSockets and IPC (UNIX sockets on UNIX based platforms, and named pipes on Windows). The IPC interface is enabled by default and exposes all the APIs supported by ebakus , whereas the HTTP,WS and GraphQL interfaces need to manually be enabled and only expose a subset of APIs due to security reasons. These can be turned on/off and configured as you\u2019d expect. HTTP based JSON-RPC API options: --rpc Enable the HTTP-RPC server --rpcaddr HTTP-RPC server listening interface (default: localhost ) --rpcport HTTP-RPC server listening port (default: 8545 ) --rpcapi API\u2019s offered over the HTTP-RPC interface (default: db,dpos,eth,net,web3 ) --rpccorsdomain Comma separated list of domains from which to accept cross origin requests (browser enforced) --rpcvhosts Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts * wildcard. (default: localhost ) --ws Enable the WS-RPC server --wsaddr WS-RPC server listening interface (default: localhost ) --wsport WS-RPC server listening port (default: 8546 ) --wsapi API\u2019s offered over the WS-RPC interface (default: db,dpos,eth,net,web3 ) --wsorigins Origins from which to accept websockets requests --ipcdisable Disable the IPC-RPC server --ipcapi API\u2019s offered over the IPC-RPC interface (default: admin,db,debug,dpos,eth,miner,net,personal,shh,txpool,web3 ) --ipcpath Filename for IPC socket/pipe within the datadir (explicit paths escape it) --graphql Enable the GraphQL server --graphql.addr GraphQL server listening interface (default: localhost ) --graphql.port GraphQL server listening port (default: 8547 ) --graphql.corsdomain Comma separated list of domains from which to accept cross origin requests (browser enforced) --graphql.vhosts Comma separated list of virtual hostnames from which to accept requests (server enforced). Accepts * wildcard. (default: localhost ) You\u2019ll need to use your own programming environments\u2019 capabilities (libraries, tools, etc) to connect via HTTP, WS or IPC to a ebakus node configured with the above flags and you\u2019ll need to speak JSON-RPC on all transports. You can reuse the same connection for multiple requests! Tip Please understand the security implications of opening up an HTTP/WS/GraphQL based transport before doing so! Hackers on the internet are actively trying to subvert Ebakus nodes with exposed APIs! Further, all browser tabs can access locally running web servers, so malicious web pages could try to subvert locally available APIs! Example Here is an example command for starting up a node on testnet with opened RPC/WS transports and attached to the internal node console. docker run -ti --name ebakus-testnet-node \\ -v ~/ebakus:/root \\ -p 30403 :30403 \\ -p 8545 :8545 \\ -p 8546 :8546 \\ ebakus/go-ebakus \\ --testnet \\ --rpc --rpcaddr 0 .0.0.0 \\ --ws --wsaddr 0 .0.0.0 \\ console","title":"Programatically interfacing ebakus nodes"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-wallet/","text":"Ebakus Web Wallet \u00b6 This is the official web wallet which can be embedded into a dApp page to interact with the Ebakus blockchain. You can check the released mainnet wallet and check how it looks like inside a dApp at an existing dApp . Usage \u00b6 The suggested way of interacting with the wallet is to use the ebakus web wallet loader which loads the wallet in an iframe and provides an interface between your dApp and the ebakus wallet without giving you access to your keys. It also allows many dApps share the same wallet when running in the same browser. In case you would like to self host the wallet, you can get your own version from its GitHub repo .","title":"Ebakus wallet"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-wallet/#ebakus-web-wallet","text":"This is the official web wallet which can be embedded into a dApp page to interact with the Ebakus blockchain. You can check the released mainnet wallet and check how it looks like inside a dApp at an existing dApp .","title":"Ebakus Web Wallet"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/ebakus-wallet/#usage","text":"The suggested way of interacting with the wallet is to use the ebakus web wallet loader which loads the wallet in an iframe and provides an interface between your dApp and the ebakus wallet without giving you access to your keys. It also allows many dApps share the same wallet when running in the same browser. In case you would like to self host the wallet, you can get your own version from its GitHub repo .","title":"Usage"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/","text":"Ebakus Web Wallet Loader \u00b6 The wallet library creates an iframe and loads the web wallet library in there. It can accept custom configurations for the wallet (i.e. load custom tokens) and act as an interface between the dApp and the web wallet iframe. This way a user can use his wallet to interface with any ebakus dApp she wants without having to create new keys and manage multiple accounts, by sharing the same wallet when running in the same browser. Safari browser : Sharing the same wallet accross dApps is not supported (using Safari default settings). You can check how it looks like inside an existing dApp . The boilerplate \u00b6 The best way to start is to use the dApp Boilerplate, where you can see how you can use the wallet loader library to programatically: Send transactions Deploy contracts Interact with smart contracts Configure custom tokens Contact us at hello@ebakus.com . Have fun! Load package \u00b6 Using npm \u00b6 npm install --save ebakus-web-wallet-loader and use it like: import ebakusWallet from 'ebakus-web-wallet-loader' ebakusWallet . init () // you have to load the wallet once With a script tag from your site \u00b6 In your dApp page you have to include our Wallet Loader script. Load it from CDN: < script src = \"https://unpkg.com/ebakus-web-wallet-loader\" /> or copy it to your site: < script src = \"./dist/wallet-loader.min.js\" /> The script will expose window.ebakusWallet . You can also have a look at the example page . API \u00b6 The dApp can communicate with the wallet through the loader API. Events \u00b6 ebakusLoaded \u00b6 When loader has finished loading with the wallet loading it will dispatch the ebakusLoaded event. window . addEventListener ( 'ebakusLoaded' , ev => { console . warn ( 'Ebakus Wallet loaded' ) }, false ) ebakusCurrentProviderEndpoint \u00b6 Every time the user switches the connected node the wallet will dispatch the ebakusCurrentProviderEndpoint event. window . addEventListener ( 'ebakusCurrentProviderEndpoint' , ({ detail : endpoint }) => { console . log ( 'The web3 provider wallet is connected is:' , endpoint ) // for a new web3 instance web3 = Web3Ebakus ( new Web3 ( endpoint )) // or for using an existing one // web3.setProvider(endpoint) }, false ) ebakusConnectionStatus \u00b6 Every time the wallet connection with the node changes it will dispatch the ebakusConnectionStatus event. window . addEventListener ( 'ebakusConnectionStatus' , ({ detail : connectionStatus }) => { console . warn ( 'The wallet connection status changed to' , connectionStatus ) }, false ) ebakusBalance \u00b6 On wallet balance change it will dispatch the ebakusBalance event. window . addEventListener ( 'ebakusBalance' , ({ detail : balance }) => { console . warn ( 'The new user balance is' , web3 . utils . toWei ( balance )) }, false ) ebakusStaked \u00b6 On wallet staked amount change it will dispatch the ebakusStaked event. window . addEventListener ( 'ebakusStaked' , ({ detail : staked }) => { console . warn ( 'The new user staked amount is' , web3 . utils . toWei ( staked )) }, false ) Methods \u00b6 ebakusWallet.init(options) \u00b6 The init method can be used in order to pass custom configuration for the actual wallet. You can: point the walletLoader to your own instance of the Ebakus Wallet set custom tokens for your dApp // loading custom token to wallet ebakusWallet . init ({ // walletEndpoint: 'https://wallet.ebakus.test' // this is the default and can be ommitted tokens : [ { contract_address : '0xa679d48c57320e9f0eadb043c3ea3f8dcd97ed01' , symbol : 'SIM' , decimals : 18 , }, ], }) window . addEventListener ( 'ebakusLoaded' , ev => { console . warn ( 'Ebakus Wallet loaded' ) }, false ) ebakusWallet.isWalletFrameLoaded() \u00b6 The isWalletFrameLoaded method returns if the wallet frame has finished loading. if ( ebakusWallet . isWalletFrameLoaded ()) { // do something } ebakusWallet.getCurrentProviderEndpoint() \u00b6 The getCurrentProviderEndpoint method returns the wallet used web3 endpoint so as the dApp can connect to the same provider. ebakusWallet . getCurrentProviderEndpoint (). then ( endpoint => { console . log ( 'The web3 provider wallet is connected is:' , endpoint ) // for a new web3 instance web3 = Web3Ebakus ( new Web3 ( endpoint )) // or for using an existing one // web3.setProvider(endpoint) }) ebakusWallet.unlockWallet() \u00b6 The unlockWallet method will ask your user to unlock the wallet in case it is locked. This is not needed most times as the wallet will ask on the first wallet interaction, when needed. ebakusWallet . unlockWallet () ebakusWallet.getDefaultAddress() \u00b6 The getDefaultAddress method returns the wallet address. ebakusWallet . getDefaultAddress (). then ( address => { console . log ( 'Your wallet address is:' , address ) }) ebakusWallet.getBalance() \u00b6 The getBalance method returns the wallet balance. ebakusWallet . getBalance (). then ( balance => console . log ) ebakusWallet.getStaked() \u00b6 The getStaked method returns the wallet staked amount. ebakusWallet . getStaked (). then ( staked => console . log ) ebakusWallet.sendTransaction(tx) \u00b6 The sendTransaction method will ask user to confirm, sign and send the transaction at the network through the wallet. ebakusWallet . sendTransaction ( /* tx object */ ). then ( receipt => console . log ) Development \u00b6 Install dependencies \u00b6 npm install Compile for development (with hot-reload support) \u00b6 npm start Compile and minify for production \u00b6 npm run build","title":"Wallet loader"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakus-web-wallet-loader","text":"The wallet library creates an iframe and loads the web wallet library in there. It can accept custom configurations for the wallet (i.e. load custom tokens) and act as an interface between the dApp and the web wallet iframe. This way a user can use his wallet to interface with any ebakus dApp she wants without having to create new keys and manage multiple accounts, by sharing the same wallet when running in the same browser. Safari browser : Sharing the same wallet accross dApps is not supported (using Safari default settings). You can check how it looks like inside an existing dApp .","title":"Ebakus Web Wallet Loader"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#the-boilerplate","text":"The best way to start is to use the dApp Boilerplate, where you can see how you can use the wallet loader library to programatically: Send transactions Deploy contracts Interact with smart contracts Configure custom tokens Contact us at hello@ebakus.com . Have fun!","title":"The boilerplate"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#load-package","text":"","title":"Load package"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#using-npm","text":"npm install --save ebakus-web-wallet-loader and use it like: import ebakusWallet from 'ebakus-web-wallet-loader' ebakusWallet . init () // you have to load the wallet once","title":"Using npm"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#with-a-script-tag-from-your-site","text":"In your dApp page you have to include our Wallet Loader script. Load it from CDN: < script src = \"https://unpkg.com/ebakus-web-wallet-loader\" /> or copy it to your site: < script src = \"./dist/wallet-loader.min.js\" /> The script will expose window.ebakusWallet . You can also have a look at the example page .","title":"With a script tag from your site"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#api","text":"The dApp can communicate with the wallet through the loader API.","title":"API"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#events","text":"","title":"Events"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakusloaded","text":"When loader has finished loading with the wallet loading it will dispatch the ebakusLoaded event. window . addEventListener ( 'ebakusLoaded' , ev => { console . warn ( 'Ebakus Wallet loaded' ) }, false )","title":"ebakusLoaded"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakuscurrentproviderendpoint","text":"Every time the user switches the connected node the wallet will dispatch the ebakusCurrentProviderEndpoint event. window . addEventListener ( 'ebakusCurrentProviderEndpoint' , ({ detail : endpoint }) => { console . log ( 'The web3 provider wallet is connected is:' , endpoint ) // for a new web3 instance web3 = Web3Ebakus ( new Web3 ( endpoint )) // or for using an existing one // web3.setProvider(endpoint) }, false )","title":"ebakusCurrentProviderEndpoint"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakusconnectionstatus","text":"Every time the wallet connection with the node changes it will dispatch the ebakusConnectionStatus event. window . addEventListener ( 'ebakusConnectionStatus' , ({ detail : connectionStatus }) => { console . warn ( 'The wallet connection status changed to' , connectionStatus ) }, false )","title":"ebakusConnectionStatus"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakusbalance","text":"On wallet balance change it will dispatch the ebakusBalance event. window . addEventListener ( 'ebakusBalance' , ({ detail : balance }) => { console . warn ( 'The new user balance is' , web3 . utils . toWei ( balance )) }, false )","title":"ebakusBalance"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakusstaked","text":"On wallet staked amount change it will dispatch the ebakusStaked event. window . addEventListener ( 'ebakusStaked' , ({ detail : staked }) => { console . warn ( 'The new user staked amount is' , web3 . utils . toWei ( staked )) }, false )","title":"ebakusStaked"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#methods","text":"","title":"Methods"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakuswalletinitoptions","text":"The init method can be used in order to pass custom configuration for the actual wallet. You can: point the walletLoader to your own instance of the Ebakus Wallet set custom tokens for your dApp // loading custom token to wallet ebakusWallet . init ({ // walletEndpoint: 'https://wallet.ebakus.test' // this is the default and can be ommitted tokens : [ { contract_address : '0xa679d48c57320e9f0eadb043c3ea3f8dcd97ed01' , symbol : 'SIM' , decimals : 18 , }, ], }) window . addEventListener ( 'ebakusLoaded' , ev => { console . warn ( 'Ebakus Wallet loaded' ) }, false )","title":"ebakusWallet.init(options)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakuswalletiswalletframeloaded","text":"The isWalletFrameLoaded method returns if the wallet frame has finished loading. if ( ebakusWallet . isWalletFrameLoaded ()) { // do something }","title":"ebakusWallet.isWalletFrameLoaded()"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakuswalletgetcurrentproviderendpoint","text":"The getCurrentProviderEndpoint method returns the wallet used web3 endpoint so as the dApp can connect to the same provider. ebakusWallet . getCurrentProviderEndpoint (). then ( endpoint => { console . log ( 'The web3 provider wallet is connected is:' , endpoint ) // for a new web3 instance web3 = Web3Ebakus ( new Web3 ( endpoint )) // or for using an existing one // web3.setProvider(endpoint) })","title":"ebakusWallet.getCurrentProviderEndpoint()"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakuswalletunlockwallet","text":"The unlockWallet method will ask your user to unlock the wallet in case it is locked. This is not needed most times as the wallet will ask on the first wallet interaction, when needed. ebakusWallet . unlockWallet ()","title":"ebakusWallet.unlockWallet()"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakuswalletgetdefaultaddress","text":"The getDefaultAddress method returns the wallet address. ebakusWallet . getDefaultAddress (). then ( address => { console . log ( 'Your wallet address is:' , address ) })","title":"ebakusWallet.getDefaultAddress()"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakuswalletgetbalance","text":"The getBalance method returns the wallet balance. ebakusWallet . getBalance (). then ( balance => console . log )","title":"ebakusWallet.getBalance()"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakuswalletgetstaked","text":"The getStaked method returns the wallet staked amount. ebakusWallet . getStaked (). then ( staked => console . log )","title":"ebakusWallet.getStaked()"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#ebakuswalletsendtransactiontx","text":"The sendTransaction method will ask user to confirm, sign and send the transaction at the network through the wallet. ebakusWallet . sendTransaction ( /* tx object */ ). then ( receipt => console . log )","title":"ebakusWallet.sendTransaction(tx)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#development","text":"","title":"Development"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#install-dependencies","text":"npm install","title":"Install dependencies"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#compile-for-development-with-hot-reload-support","text":"npm start","title":"Compile for development (with hot-reload support)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/wallet-loader/#compile-and-minify-for-production","text":"npm run build","title":"Compile and minify for production"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/","text":"web3-ebakus library for web3.js \u00b6 Extend Web3.js functionality for Ebakus blockchain. Installation \u00b6 Node.js \u00b6 npm install --save web3-ebakus In the Browser \u00b6 Load it from CDN: <script src= \"https://unpkg.com/web3-ebakus\" ></script> Note You can find what is the latest version number of the library here . The script tag above to unpkg.com points to latest endpoint which does a redirect. or build running the following from the root folder of the repository: npm run-script build Then include lib/web3-ebakus.browser.min.js in your html file. This will expose the Web3Ebakus object on the window object. Requirements \u00b6 Web3 ^1.2.0 Usage \u00b6 import Web3Ebakus from 'web3-ebakus' import Web3 from 'web3' const web3 = Web3Ebakus ( new Web3 ()) You can also have a look at the example page . Methods \u00b6 web3.eth.suggestDifficulty(accountAddress) \u00b6 The suggestDifficulty queries the node for the suggested target difficulty needed for the PoW in order for a transaction to enter a block taking into account current congestion levels and address stake. The difficulty will be used in calculateWorkForTransaction . web3 . eth . suggestDifficulty ( accountAddress ) . then ( difficulty => console . log ( difficulty )) web3.eth.calculateWorkForTransaction(transaction, targetDifficulty, ctrlWorkForTransactionState, callback) \u00b6 The calculateWorkForTransaction calculates the PoW needed for a transaction to enter a block by a block producer. const tx = { /* transaction object */ } web3 . eth . calculateWorkForTransaction ( tx , /* targetDifficulty */ 1 ) . then ( tx => { /* do something with tx */ }) is also available for Account objects, which is useful for chaining The ctrlWorkForTransactionState and callback parameters are optional. ctrlWorkForTransactionState : this is an object that will be populated with some useful methods when passed. isRunning() : state of worker getCurrentWorkNonce() : returns the current workNonce while worker is running kill() : kills the worker Example let ctrl = {} // log worker state every 500ms const logger = setInterval (() => { console . log ( 'isRunning' , ctrl . isRunning ()) console . log ( 'getCurrentWorkNonce' , ctrl . getCurrentWorkNonce ()) // stop logging once worker finished if ( ! ctrl . isRunning ()) { clearInterval ( logger ) } }, 500 ) // kill worker after 3seconds // setTimeout(() => { // ctrl.kill(); // }, 3000); web3 . eth . calculateWorkForTransaction ( transaction , 1 , ctrl ). then ( tx => { /* do something with tx */ }) callback : you can read more here web3.eth.estimatePoWTime(targetDifficulty, gas, callback) \u00b6 The estimatePoWTime estimates how much time the current hardware will take for doing PoW based on target difficulty and transaction gas. web3 . eth . suggestDifficulty ( accountAddress ). then ( difficulty => { web3 . eth . estimatePoWTime ( difficulty , /* gas */ 100000 ) . then ( powTimeInSeconds => console . log ( powTimeInSeconds )) }) targetDifficulty : this is the target difficulty to achieve so as transaction gets produced. (default = 2) gas : this is the transaction gas. (default = 21000) callback : you can read more here web3.eth.getAbiForAddress(contractAddress) \u00b6 The getAbiForAddress returns the ABI for a contract, if this has been set by the developer. web3 . eth . getAbiForAddress ( contractAddress ) . then ( abi => console . log ( JSON . parse ( abi ))) web3.eth.getStaked(accountAddress, blockNumber) \u00b6 The getStaked returns the staked amount for an account. accountAddress : the account address. blockNumber : block number from which to read the staked amount. You can use latest string for fetching from latest block. web3.db.select(contractAddress, tableName, whereCondition, orderByColumn, blockNumber) \u00b6 The db.select allows performing selects with conditions ordered by column name. contractAddress : contract address that created the DB tables tableName : table name whereClause : where condition for finding an entry Supported conditions are \u201c<\u201d, \u201c>\u201d, \u201c=\u201d, \u201c==\u201d, \u201c<=\u201d, \u201c>=\u201d, \u201c!=\u201d, \u201cLIKE\u201d Example use cases Phone = \"555-1111\" , Id >= 3 orderClause : order clause for sorting the results using \u201cASC\u201d or \u201cDESC\u201d Example use case: Phone DESC blockNumber : block number to read from EbakusDB state. You can use latest string for fetching from latest block. web3 . db . select ( contractAddress , tableName , whereCondition , orderByColumn , blockNumber ) . then ( iterator => web3 . db . next ( iter ). then ( entry => console . log ( entry ) ) web3.db.next(iter) \u00b6 The db.next returns the next result of the select performed through web3.db.select() . web3.db.releaseIterator(iter) \u00b6 The db.releaseIterator should be called once, if not all iterator entries has been read using db.next , in order the iterator taken from db.select to be released. web3.db.get(contractAddress, tableName, whereCondition, orderByColumn, blockNumber) \u00b6 The db.get allows fetching a single item. Check for its params at web3.db.select() . web3 . db . get ( contractAddress , tableName , whereCondition , orderByColumn , blockNumber ) . then ( entry => console . log ( entry ))","title":"web3-ebakus"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3-ebakus-library-for-web3js","text":"Extend Web3.js functionality for Ebakus blockchain.","title":"web3-ebakus library for web3.js"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#installation","text":"","title":"Installation"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#nodejs","text":"npm install --save web3-ebakus","title":"Node.js"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#in-the-browser","text":"Load it from CDN: <script src= \"https://unpkg.com/web3-ebakus\" ></script> Note You can find what is the latest version number of the library here . The script tag above to unpkg.com points to latest endpoint which does a redirect. or build running the following from the root folder of the repository: npm run-script build Then include lib/web3-ebakus.browser.min.js in your html file. This will expose the Web3Ebakus object on the window object.","title":"In the Browser"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#requirements","text":"Web3 ^1.2.0","title":"Requirements"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#usage","text":"import Web3Ebakus from 'web3-ebakus' import Web3 from 'web3' const web3 = Web3Ebakus ( new Web3 ()) You can also have a look at the example page .","title":"Usage"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#methods","text":"","title":"Methods"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3ethsuggestdifficultyaccountaddress","text":"The suggestDifficulty queries the node for the suggested target difficulty needed for the PoW in order for a transaction to enter a block taking into account current congestion levels and address stake. The difficulty will be used in calculateWorkForTransaction . web3 . eth . suggestDifficulty ( accountAddress ) . then ( difficulty => console . log ( difficulty ))","title":"web3.eth.suggestDifficulty(accountAddress)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3ethcalculateworkfortransactiontransaction-targetdifficulty-ctrlworkfortransactionstate-callback","text":"The calculateWorkForTransaction calculates the PoW needed for a transaction to enter a block by a block producer. const tx = { /* transaction object */ } web3 . eth . calculateWorkForTransaction ( tx , /* targetDifficulty */ 1 ) . then ( tx => { /* do something with tx */ }) is also available for Account objects, which is useful for chaining The ctrlWorkForTransactionState and callback parameters are optional. ctrlWorkForTransactionState : this is an object that will be populated with some useful methods when passed. isRunning() : state of worker getCurrentWorkNonce() : returns the current workNonce while worker is running kill() : kills the worker Example let ctrl = {} // log worker state every 500ms const logger = setInterval (() => { console . log ( 'isRunning' , ctrl . isRunning ()) console . log ( 'getCurrentWorkNonce' , ctrl . getCurrentWorkNonce ()) // stop logging once worker finished if ( ! ctrl . isRunning ()) { clearInterval ( logger ) } }, 500 ) // kill worker after 3seconds // setTimeout(() => { // ctrl.kill(); // }, 3000); web3 . eth . calculateWorkForTransaction ( transaction , 1 , ctrl ). then ( tx => { /* do something with tx */ }) callback : you can read more here","title":"web3.eth.calculateWorkForTransaction(transaction, targetDifficulty, ctrlWorkForTransactionState, callback)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3ethestimatepowtimetargetdifficulty-gas-callback","text":"The estimatePoWTime estimates how much time the current hardware will take for doing PoW based on target difficulty and transaction gas. web3 . eth . suggestDifficulty ( accountAddress ). then ( difficulty => { web3 . eth . estimatePoWTime ( difficulty , /* gas */ 100000 ) . then ( powTimeInSeconds => console . log ( powTimeInSeconds )) }) targetDifficulty : this is the target difficulty to achieve so as transaction gets produced. (default = 2) gas : this is the transaction gas. (default = 21000) callback : you can read more here","title":"web3.eth.estimatePoWTime(targetDifficulty, gas, callback)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3ethgetabiforaddresscontractaddress","text":"The getAbiForAddress returns the ABI for a contract, if this has been set by the developer. web3 . eth . getAbiForAddress ( contractAddress ) . then ( abi => console . log ( JSON . parse ( abi )))","title":"web3.eth.getAbiForAddress(contractAddress)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3ethgetstakedaccountaddress-blocknumber","text":"The getStaked returns the staked amount for an account. accountAddress : the account address. blockNumber : block number from which to read the staked amount. You can use latest string for fetching from latest block.","title":"web3.eth.getStaked(accountAddress, blockNumber)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3dbselectcontractaddress-tablename-wherecondition-orderbycolumn-blocknumber","text":"The db.select allows performing selects with conditions ordered by column name. contractAddress : contract address that created the DB tables tableName : table name whereClause : where condition for finding an entry Supported conditions are \u201c<\u201d, \u201c>\u201d, \u201c=\u201d, \u201c==\u201d, \u201c<=\u201d, \u201c>=\u201d, \u201c!=\u201d, \u201cLIKE\u201d Example use cases Phone = \"555-1111\" , Id >= 3 orderClause : order clause for sorting the results using \u201cASC\u201d or \u201cDESC\u201d Example use case: Phone DESC blockNumber : block number to read from EbakusDB state. You can use latest string for fetching from latest block. web3 . db . select ( contractAddress , tableName , whereCondition , orderByColumn , blockNumber ) . then ( iterator => web3 . db . next ( iter ). then ( entry => console . log ( entry ) )","title":"web3.db.select(contractAddress, tableName, whereCondition, orderByColumn, blockNumber)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3dbnextiter","text":"The db.next returns the next result of the select performed through web3.db.select() .","title":"web3.db.next(iter)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3dbreleaseiteratoriter","text":"The db.releaseIterator should be called once, if not all iterator entries has been read using db.next , in order the iterator taken from db.select to be released.","title":"web3.db.releaseIterator(iter)"},{"location":"developing-applications-with-ebakus/the-ebakus-development-stack/web3-ebakus/#web3dbgetcontractaddress-tablename-wherecondition-orderbycolumn-blocknumber","text":"The db.get allows fetching a single item. Check for its params at web3.db.select() . web3 . db . get ( contractAddress , tableName , whereCondition , orderByColumn , blockNumber ) . then ( entry => console . log ( entry ))","title":"web3.db.get(contractAddress, tableName, whereCondition, orderByColumn, blockNumber)"}]}